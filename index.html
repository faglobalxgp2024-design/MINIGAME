<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>XGP 장기 미니게임</title>
  <style>
    :root{
      --bgA:#d9b67c;
      --bgB:#caa56b;
      --bgC:#b78b55;

      --paper:#f1d6a6;
      --wood:#c79b63;
      --wood2:#b78953;

      --grid:#51361f;
      --gridSoft: rgba(81,54,31,.55);
      --ink:#2a1a10;

      --red:#d63a2b;
      --red2:#ff6a5f;
      --blue:#1e5bd8;
      --blue2:#5a8cff;

      --ui:#ffffff;
      --uiSoft: rgba(255,255,255,.80);
      --uiGlass: rgba(255,255,255,.16);
      --shadow: 0 18px 0 rgba(0,0,0,.20);
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; width:100%; }
    body{
      margin:0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: var(--ui);
      background:
        radial-gradient(900px 600px at 15% 10%, rgba(255,255,255,.22) 0%, rgba(255,255,255,0) 55%),
        radial-gradient(1000px 700px at 85% 20%, rgba(255,255,255,.14) 0%, rgba(255,255,255,0) 58%),
        linear-gradient(90deg, var(--bgA), var(--bgB) 50%, var(--bgC));
      overflow-x:hidden;
      overscroll-behavior: none;
    }

    body:before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background-image:
        radial-gradient(rgba(255,255,255,.10) 1px, transparent 1px),
        radial-gradient(rgba(0,0,0,.05) 1px, transparent 1px);
      background-size: 52px 52px, 86px 86px;
      background-position: 0 0, 22px 28px;
      opacity:.30;
      mix-blend-mode: overlay;
    }

    .page{
      min-height:100%;
      width:100%;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding: calc(18px + env(safe-area-inset-top)) 14px calc(18px + env(safe-area-inset-bottom)) 14px;
      overflow-x:hidden;
    }

    .shell{
      width: min(1020px, 100%);
      display:grid;
      grid-template-columns: 1fr 300px;
      gap: 14px;
      align-items: start;
    }
    @media (max-width: 960px){
      .shell{ grid-template-columns: 1fr; }
    }

    .card{
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.12));
      border: 2px solid rgba(255,255,255,.26);
      box-shadow: var(--shadow);
      position: relative;
      overflow:hidden;
      max-width:100%;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }

    .frame{
      border-radius: 18px;
      border: 2px solid rgba(58,36,20,.45);
      background:
        linear-gradient(180deg, rgba(0,0,0,.06), rgba(0,0,0,.10));
      padding: 12px;
      max-width:100%;
    }

    .toast{
      position:absolute;
      left:50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(.96);
      padding: 14px 18px;
      border-radius: 18px;
      border: 2px solid rgba(255,255,255,.26);
      background:
        radial-gradient(220px 140px at 30% 30%, rgba(255,255,255,.22), rgba(255,255,255,0) 55%),
        rgba(0,0,0,.42);
      color: rgba(255,255,255,.98);
      font-weight: 1000;
      letter-spacing: .8px;
      box-shadow: 0 14px 0 rgba(0,0,0,.22);
      display:none;
      align-items:center;
      gap: 12px;
      z-index: 40;
      user-select:none;
      pointer-events:none;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      white-space: nowrap;
    }
    .toast .dot{
      width:12px;height:12px;border-radius:99px;
      background: #ffd073;
      box-shadow: 0 0 0 7px rgba(255,208,115,.18);
      flex:0 0 auto;
    }
    .toast .big{
      font-size: 34px;
      line-height: 1;
      text-shadow: 0 2px 0 rgba(0,0,0,.18);
    }
    .toast .sub{
      font-size: 12px;
      opacity:.92;
      font-weight: 900;
      letter-spacing: .2px;
      margin-left: 2px;
    }
    .toast.show{
      display:flex;
      animation: toastPop .95s ease both;
    }
    @keyframes toastPop{
      0%{ opacity:0; transform: translate(-50%, -55%) scale(.92); }
      18%{ opacity:1; transform: translate(-50%, -50%) scale(1.06); }
      60%{ opacity:1; transform: translate(-50%, -50%) scale(1.02); }
      100%{ opacity:0; transform: translate(-50%, -52%) scale(.98); }
    }

    .topbar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      padding: 10px 14px;
      gap: 10px;
      flex-wrap:wrap;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight: 900;
      letter-spacing:.4px;
      min-width: 220px;
      color: rgba(255,255,255,.95);
    }
    .brand .tag{
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,.25);
      background: rgba(0,0,0,.10);
      color: rgba(255,255,255,.92);
      white-space: nowrap;
    }

    .topRight{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap: 6px;
      flex:1;
      min-width: 220px;
    }

    .help{
      font-size: 12px;
      color: rgba(255,255,255,.88);
      opacity:.95;
      text-align:right;
    }

    .recordRow{
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .record{
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.16);
      color: rgba(255,255,255,.90);
      white-space: nowrap;
    }
    .record b{ color: #ffd073; }

    .stats{
      display:flex;
      gap: 10px;
      padding: 0 14px 12px 14px;
      flex-wrap:wrap;
    }
    .pill{
      flex:1;
      min-width: 160px;
      background: rgba(0,0,0,.18);
      border: 2px solid rgba(255,255,255,.22);
      border-radius: 14px;
      padding: 10px 12px;
    }
    .pill .k{ font-size: 12px; color: rgba(255,255,255,.82); }
    .pill .v{ font-size: 16px; font-weight: 900; margin-top: 6px; }

    .boardWrap{
      padding: 0 14px 14px 14px;
      max-width:100%;
    }
    .boardStage{
      border-radius: 16px;
      border: 2px solid rgba(58,36,20,.35);
      background:
        radial-gradient(1200px 700px at 40% 10%, rgba(255,255,255,.45) 0%, rgba(255,255,255,0) 62%),
        linear-gradient(180deg, rgba(255,255,255,.18), rgba(0,0,0,.06)),
        linear-gradient(90deg, rgba(205,155,95,.35), rgba(255,255,255,0), rgba(175,120,70,.30));
      box-shadow:
        inset 0 0 0 2px rgba(0,0,0,.14),
        0 16px 0 rgba(0,0,0,.16);
      padding: 12px;
      max-width:100%;
      position: relative;
    }

    canvas{
      width: 100%;
      max-width: 640px;
      height: auto;
      aspect-ratio: 9 / 10;
      border-radius: 14px;
      border: 2px solid rgba(58,36,20,.25);
      background:
        radial-gradient(900px 600px at 35% 20%, rgba(255,255,255,.55) 0%, rgba(255,255,255,0) 60%),
        linear-gradient(180deg, rgba(255,255,255,.22), rgba(0,0,0,.06)),
        linear-gradient(90deg, rgba(241,214,166,.85), rgba(225,190,130,.88) 55%, rgba(214,172,110,.86));
      touch-action: none;
      user-select: none;
      display:block;
      margin: 0 auto;
    }

    .bottomBtns{
      display:flex;
      gap: 10px;
      padding: 0 14px 14px 14px;
      flex-wrap:wrap;
    }
    button{
      flex:1;
      min-width: 140px;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.95);
      font-family: inherit;
      font-weight: 900;
      padding: 12px 12px;
      cursor:pointer;
      box-shadow: 0 8px 0 rgba(0,0,0,.20);
      transform: translateY(0);
      transition: transform .05s ease;
    }
    button:active{ transform: translateY(3px); box-shadow: 0 5px 0 rgba(0,0,0,.20); }
    button.primary{
      background: rgba(20,10,0,.20);
      border-color: rgba(255, 208, 115, .55);
    }
    button.danger{
      border-color: rgba(255,93,93,.55);
      background: rgba(255,93,93,.12);
    }

    .side{
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      max-width:100%;
    }
    .side h2{
      margin:0;
      font-size: 14px;
      font-weight: 900;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 8px;
      color: rgba(255,255,255,.95);
    }
    .mini{
      font-size: 12px;
      color: rgba(255,255,255,.86);
      padding: 10px 12px;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,.20);
      background: rgba(0,0,0,.16);
      line-height: 1.55;
    }

    .capBox{
      padding: 10px 12px;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,.20);
      background: rgba(0,0,0,.16);
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .capTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 8px;
      font-size: 12px;
      color: rgba(255,255,255,.86);
      font-weight: 900;
    }
    .capRow{
      display:flex;
      flex-wrap:wrap;
      gap: 6px;
      min-height: 36px;
      align-items:center;
    }
    .capChip{
      width: 34px;
      height: 34px;
      border-radius: 12px;
      border: 2px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 6px 0 rgba(0,0,0,.16);
      overflow:hidden;
    }
    .capChip img{ width: 34px; height: 34px; display:block; }

    .log{
      padding: 10px 12px;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,.20);
      background: rgba(0,0,0,.16);
      min-height: 180px;
      max-height: 300px;
      overflow:auto;
      white-space: pre-wrap;
      font-size: 12px;
      line-height: 1.55;
      color: rgba(255,255,255,.84);
    }

    .overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
      background: rgba(0,0,0,.50);
      z-index: 60;
    }
    .overlay.show{ display:flex; }

    .modal{
      width: min(560px, 100%);
      padding: 14px;
      position:relative;
      overflow:hidden;
    }
    .modal h3{
      margin:0 0 8px 0;
      font-size: 18px;
      font-weight: 900;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .modal p{
      margin: 0 0 12px 0;
      color: rgba(255,255,255,.88);
      line-height: 1.6;
      font-size: 13px;
    }
    .kbd{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,.20);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.95);
      font-weight: 900;
      font-size: 12px;
    }

    .flash{
      position:fixed;
      inset:0;
      pointer-events:none;
      opacity:0;
      background: radial-gradient(800px 600px at 50% 40%, rgba(255,255,255,.75), rgba(255,255,255,0) 65%);
      z-index: 80;
    }
    .flash.on{ animation: flashBoom .65s ease both; }
    @keyframes flashBoom{
      0%{ opacity:0; }
      20%{ opacity:1; }
      100%{ opacity:0; }
    }

    .fireworks{
      position:absolute;
      inset:-20px;
      pointer-events:none;
      opacity:0;
      background:
        radial-gradient(240px 240px at 20% 30%, rgba(255,208,115,.70), rgba(255,208,115,0) 70%),
        radial-gradient(260px 260px at 75% 35%, rgba(90,140,255,.55), rgba(90,140,255,0) 72%),
        radial-gradient(280px 280px at 45% 78%, rgba(255,106,95,.55), rgba(255,106,95,0) 72%),
        radial-gradient(220px 220px at 82% 70%, rgba(57,217,138,.45), rgba(57,217,138,0) 72%);
      filter: blur(0.2px);
    }
    .fireworks.on{
      opacity:1;
      animation: fwPulse 1.6s ease both;
    }
    @keyframes fwPulse{
      0%{ transform: scale(.98); opacity:0; }
      15%{ transform: scale(1.02); opacity:1; }
      100%{ transform: scale(1.05); opacity:.00; }
    }
  </style>
</head>

<body>
  <div class="flash" id="flash"></div>

  <div class="page">
    <div class="shell">
      <div class="card frame" id="mainCard">
        <div class="toast" id="toast">
          <span class="dot"></span>
          <div>
            <div class="big" id="toastText">장군!</div>
            <div class="sub" id="toastSub">—</div>
          </div>
        </div>

        <div class="topbar">
          <div class="brand">
            <span>XGP</span>
            <span class="tag">장기 미니게임</span>
          </div>

          <div class="topRight">
            <div class="recordRow">
              <div class="record">최고 연승: <b id="bestStreakTxt">0</b></div>
              <div class="record">최고 난이도: <b id="bestDiffTxt">Lv 1</b></div>
            </div>
            <div class="help">클릭/탭: 말 선택 → 목적지 (AI는 짧게 둠)</div>
          </div>
        </div>

        <div class="stats">
          <div class="pill">
            <div class="k">턴</div>
            <div class="v" id="turnTxt">漢(플레이어)</div>
          </div>
          <div class="pill">
            <div class="k">난이도</div>
            <div class="v" id="diffTxt">Lv 1</div>
          </div>
          <div class="pill">
            <div class="k">연승</div>
            <div class="v" id="streakTxt">0</div>
          </div>
        </div>

        <div class="boardWrap">
          <div class="boardStage">
            <canvas id="cv" width="900" height="1000"></canvas>
          </div>
        </div>

        <div class="bottomBtns">
          <button class="primary" id="btnNew">다시 시작</button>
          <button id="btnHelp">도움말</button>
          <button class="danger" id="btnReset">연승 리셋</button>
        </div>
      </div>

      <div class="card side">
        <h2>
          <span>플레이 정보</span>
          <span id="statusTxt" style="font-size:12px;color:rgba(255,255,255,.86);font-weight:900;">진행중</span>
        </h2>

        <div class="mini">
          규칙: <b>상대 ‘장(漢/楚)’을 잡으면 승리</b> 또는 <b>외통수(체크메이트)면 즉시 승리</b><br/>
          말을 둘 때 <b>“탁”</b> 소리가 납니다.<br/>
          <b>장군</b>이면 화면에 표시 + 소리.
        </div>

        <div class="capBox">
          <div class="capTitle">
            <span>漢(플레이어)가 잡은 말</span>
            <span id="capHanCount">0</span>
          </div>
          <div class="capRow" id="capHan"></div>

          <div class="capTitle" style="margin-top:4px;">
            <span>楚(AI)가 잡은 말</span>
            <span id="capChoCount">0</span>
          </div>
          <div class="capRow" id="capCho"></div>
        </div>

        <div class="capBox">
          <div class="capTitle"><span>수순 로그</span><span id="logHint">—</span></div>
          <div class="log" id="log"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay show" id="helpOverlay">
    <div class="card modal">
      <h3>
        <span>도움말</span>
        <span class="kbd">漢 vs 楚</span>
      </h3>
      <p>
        당신은 <b>漢(아래)</b>입니다.<br/>
        목표: <b>상대 장(楚) 잡기</b> 또는 <b>외통수(체크메이트)</b><br/><br/>
        조작: <span class="kbd">말 클릭/탭</span> → <span class="kbd">이동 칸 클릭/탭</span><br/>
        <b>불가능한 수(내 장이 장군 상태가 되는 수)</b>는 자동으로 막습니다.
      </p>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="primary" id="btnGo" style="flex:1;">게임 시작</button>
        <button id="btnCloseHelp" style="flex:1;">닫기</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="resultOverlay">
    <div class="card modal">
      <div class="fireworks" id="fw"></div>
      <h3 id="resultTitle">결과</h3>
      <p id="resultBody"></p>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="primary" id="btnAgain" style="flex:1;">다시 하기</button>
        <button id="btnCloseResult" style="flex:1;">닫기</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const UI = {
    turnTxt: document.getElementById('turnTxt'),
    diffTxt: document.getElementById('diffTxt'),
    streakTxt: document.getElementById('streakTxt'),
    statusTxt: document.getElementById('statusTxt'),

    bestStreakTxt: document.getElementById('bestStreakTxt'),
    bestDiffTxt: document.getElementById('bestDiffTxt'),

    log: document.getElementById('log'),
    logHint: document.getElementById('logHint'),

    capHan: document.getElementById('capHan'),
    capCho: document.getElementById('capCho'),
    capHanCount: document.getElementById('capHanCount'),
    capChoCount: document.getElementById('capChoCount'),

    btnNew: document.getElementById('btnNew'),
    btnHelp: document.getElementById('btnHelp'),
    btnReset: document.getElementById('btnReset'),

    helpOverlay: document.getElementById('helpOverlay'),
    btnGo: document.getElementById('btnGo'),
    btnCloseHelp: document.getElementById('btnCloseHelp'),

    resultOverlay: document.getElementById('resultOverlay'),
    resultTitle: document.getElementById('resultTitle'),
    resultBody: document.getElementById('resultBody'),
    btnAgain: document.getElementById('btnAgain'),
    btnCloseResult: document.getElementById('btnCloseResult'),

    toast: document.getElementById('toast'),
    toastText: document.getElementById('toastText'),
    toastSub: document.getElementById('toastSub'),

    flash: document.getElementById('flash'),
    fw: document.getElementById('fw'),
  };

  // -------------------------
  // Audio
  // -------------------------
  let audioCtx = null;
  function ensureAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  function playTak(){
    if(!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const dur = 0.085;

    const bufferSize = Math.floor(audioCtx.sampleRate * dur);
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<bufferSize;i++){
      const env = Math.exp(-i/(bufferSize*0.18));
      data[i] = (Math.random()*2-1) * env;
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;

    const band = audioCtx.createBiquadFilter();
    band.type = "bandpass";
    band.frequency.setValueAtTime(1100, t0);
    band.Q.setValueAtTime(2.2, t0);

    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.0, t0);
    gain.gain.linearRampToValueAtTime(0.9, t0 + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, t0 + dur);

    noise.connect(band);
    band.connect(gain);
    gain.connect(audioCtx.destination);

    const osc = audioCtx.createOscillator();
    osc.type = "triangle";
    const og = audioCtx.createGain();
    osc.frequency.setValueAtTime(240, t0);
    og.gain.setValueAtTime(0.0001, t0);
    og.gain.linearRampToValueAtTime(0.22, t0 + 0.006);
    og.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.07);
    osc.connect(og);
    og.connect(audioCtx.destination);

    noise.start(t0);
    noise.stop(t0 + dur);
    osc.start(t0);
    osc.stop(t0 + 0.09);
  }

  function playJanggun(){
    if(!audioCtx) return;
    const t0 = audioCtx.currentTime;

    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const f = audioCtx.createBiquadFilter();

    osc1.type = "sawtooth";
    osc2.type = "square";
    f.type = "lowpass";
    f.frequency.setValueAtTime(1600, t0);
    f.Q.setValueAtTime(1.0, t0);

    const seq = [
      {start:0.00, dur:0.10, f1:560, f2:840},
      {start:0.14, dur:0.12, f1:660, f2:990},
    ];

    g.gain.setValueAtTime(0.0001, t0);
    for(const s of seq){
      const a = t0 + s.start;
      g.gain.setValueAtTime(0.0001, a);
      g.gain.linearRampToValueAtTime(0.35, a + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, a + s.dur);

      osc1.frequency.setValueAtTime(s.f1, a);
      osc1.frequency.linearRampToValueAtTime(s.f1*1.12, a + s.dur);

      osc2.frequency.setValueAtTime(s.f2, a);
      osc2.frequency.linearRampToValueAtTime(s.f2*1.10, a + s.dur);
    }

    osc1.connect(f);
    osc2.connect(f);
    f.connect(g);
    g.connect(audioCtx.destination);

    osc1.start(t0);
    osc2.start(t0);
    osc1.stop(t0 + 0.35);
    osc2.stop(t0 + 0.35);
  }

  function playWin(){
    if(!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const o2 = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "triangle";
    o2.type = "sine";
    o.frequency.setValueAtTime(440, t0);
    o.frequency.exponentialRampToValueAtTime(880, t0 + 0.18);
    o2.frequency.setValueAtTime(660, t0);
    o2.frequency.exponentialRampToValueAtTime(1320, t0 + 0.18);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.35, t0 + 0.04);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.35);
    o.connect(g); o2.connect(g); g.connect(audioCtx.destination);
    o.start(t0); o2.start(t0);
    o.stop(t0 + 0.36); o2.stop(t0 + 0.36);
  }

  function playLose(){
    if(!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "sawtooth";
    o.frequency.setValueAtTime(240, t0);
    o.frequency.exponentialRampToValueAtTime(110, t0 + 0.25);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.25, t0 + 0.03);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.35);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + 0.36);
  }

  // -------------------------
  // Game constants
  // -------------------------
  const SIDE = { HAN:'H', CHO:'C' };
  const TYPE = { G:'G', A:'A', R:'R', H:'H', E:'E', C:'C', S:'S' };
  const PIECE_VALUE = {
    [TYPE.G]: 100000,
    [TYPE.R]: 950,
    [TYPE.C]: 500,
    [TYPE.H]: 360,
    [TYPE.E]: 320,
    [TYPE.A]: 220,
    [TYPE.S]: 130
  };
  const HANJA = { [TYPE.R]:'車',[TYPE.H]:'馬',[TYPE.E]:'象',[TYPE.A]:'士',[TYPE.C]:'炮',[TYPE.S]:'卒' };
  function pieceText(p){
    if(p.type === TYPE.G) return (p.side===SIDE.HAN) ? '漢' : '楚';
    return HANJA[p.type] || '?';
  }

  function pieceFontSize(type){
    if(type === TYPE.G) return 82;
    if(type === TYPE.A || type === TYPE.S) return 56;
    if(type === TYPE.H || type === TYPE.E || type === TYPE.R || type === TYPE.C) return 70;
    return 66;
  }
  function chipFontSize(type){
    if(type === TYPE.G) return 28;
    if(type === TYPE.A || type === TYPE.S) return 18;
    return 22;
  }

  // -------------------------
  // State
  // -------------------------
  let board = null;
  let turn = SIDE.HAN;
  let gameOver = false;
  let thinking = false;

  let selected = null;
  let legalCache = [];

  let winStreak = loadStreak();
  let bestStreak = loadBestStreak();
  let bestDiffLevel = loadBestDiffLevel();

  let capturedByHan = [];
  let capturedByCho = [];

  // ✅ AI: 연승 올라갈수록 더 빨리 두고(딜레이 감소), 더 오래 생각(시간 증가), 더 깊게(깊이 증가)
  function getDifficulty(streak){
    // "Lv"는 무한. 0연승도 Lv1.
    const level = Math.max(1, streak + 1);

    // 탐색 깊이 상한: 초반부터 빠르게 증가 (Lv 1~)
    // Lv1:3, Lv2:4, Lv3:5 ... (중간부터는 더 가파르게)
    const depthCap = Math.min(14, 3 + Math.floor(level*0.9) + Math.floor(level/6));

    // 시간 제한: 레벨에 따라 빠르게 증가 (너무 늘면 브라우저 버벅임 방지로 상한)
    const timeMs = Math.min(4500, 240 + level*240 + Math.floor(level*level*18));

    // 랜덤(실수): 초반만 조금, 금방 0에 수렴
    const noise = Math.max(0, 0.16 * Math.exp(-level/4.2));

    // AI 딜레이: 초반 600ms, 점점 줄어서 최소 120ms
    const delayMs = Math.max(120, 600 - level*40);

    return { level, depthCap, timeMs, noise, delayMs };
  }

  // -------------------------
  // Geometry
  // -------------------------
  const GRID = { cols:9, rows:10 };
  const pad = 44;
  const cellW = (cv.width - pad*2) / (GRID.cols-1);
  const cellH = (cv.height - pad*2) / (GRID.rows-1);

  function xyToPx(x,y){ return { px: pad + x*cellW, py: pad + y*cellH }; }
  function inside(x,y){ return x>=0 && x<9 && y>=0 && y<10; }
  function pxToXY(px,py){
    const x = Math.round((px - pad)/cellW);
    const y = Math.round((py - pad)/cellH);
    if(x<0||x>=GRID.cols||y<0||y>=GRID.rows) return null;
    const p = xyToPx(x,y);
    const dx = px - p.px, dy = py - p.py;
    if (dx*dx + dy*dy > (Math.min(cellW,cellH)*0.48)**2) return null;
    return {x,y};
  }

  // -------------------------
  // Records (best streak / best level)
  // -------------------------
  function updateRecordsUI(){
    UI.bestStreakTxt.textContent = String(bestStreak);
    UI.bestDiffTxt.textContent = `Lv ${bestDiffLevel}`;
  }
  function maybeUpdateRecords(){
    if(winStreak > bestStreak){
      bestStreak = winStreak;
      saveBestStreak(bestStreak);
    }
    const lv = getDifficulty(winStreak).level;
    if(lv > bestDiffLevel){
      bestDiffLevel = lv;
      saveBestDiffLevel(bestDiffLevel);
    }
    updateRecordsUI();
  }

  // -------------------------
  // Board setup
  // -------------------------
  function makeEmptyBoard(){
    const b = [];
    for(let y=0;y<10;y++){
      const row = [];
      for(let x=0;x<9;x++) row.push(null);
      b.push(row);
    }
    return b;
  }
  function put(x,y, side, type){ board[y][x] = { side, type }; }
  function get(x,y){ return board[y][x]; }

  function resetCaptured(){
    capturedByHan = [];
    capturedByCho = [];
    renderCaptured();
  }

  function placeInitial(){
    board = makeEmptyBoard();
    resetCaptured();
    particles = [];
    movingPiece = null;

    // 楚 (top)
    put(0,0, SIDE.CHO, TYPE.R); put(8,0, SIDE.CHO, TYPE.R);
    put(1,0, SIDE.CHO, TYPE.H); put(7,0, SIDE.CHO, TYPE.H);
    put(2,0, SIDE.CHO, TYPE.E); put(6,0, SIDE.CHO, TYPE.E);
    put(3,0, SIDE.CHO, TYPE.A); put(5,0, SIDE.CHO, TYPE.A);
    put(4,1, SIDE.CHO, TYPE.G);
    put(1,2, SIDE.CHO, TYPE.C); put(7,2, SIDE.CHO, TYPE.C);
    put(0,3, SIDE.CHO, TYPE.S); put(2,3, SIDE.CHO, TYPE.S); put(4,3, SIDE.CHO, TYPE.S); put(6,3, SIDE.CHO, TYPE.S); put(8,3, SIDE.CHO, TYPE.S);

    // 漢 (bottom)
    put(0,9, SIDE.HAN, TYPE.R); put(8,9, SIDE.HAN, TYPE.R);
    put(1,9, SIDE.HAN, TYPE.H); put(7,9, SIDE.HAN, TYPE.H);
    put(2,9, SIDE.HAN, TYPE.E); put(6,9, SIDE.HAN, TYPE.E);
    put(3,9, SIDE.HAN, TYPE.A); put(5,9, SIDE.HAN, TYPE.A);
    put(4,8, SIDE.HAN, TYPE.G);
    put(1,7, SIDE.HAN, TYPE.C); put(7,7, SIDE.HAN, TYPE.C);
    put(0,6, SIDE.HAN, TYPE.S); put(2,6, SIDE.HAN, TYPE.S); put(4,6, SIDE.HAN, TYPE.S); put(6,6, SIDE.HAN, TYPE.S); put(8,6, SIDE.HAN, TYPE.S);

    turn = SIDE.HAN;
    gameOver = false;
    thinking = false;
    selected = null;
    legalCache = [];
    UI.statusTxt.textContent = "진행중";
    UI.log.textContent = "";
    appendLog("새 판 시작! (漢: 플레이어, 楚: AI)");
    syncUI();
    maybeUpdateRecords();
  }

  // -------------------------
  // Palace / diagonals
  // -------------------------
  function inPalace(side, x,y){
    if(x<3||x>5) return false;
    if(side===SIDE.CHO) return (y>=0 && y<=2);
    return (y>=7 && y<=9);
  }
  function inAnyPalace(x,y){
    return inPalace(SIDE.CHO,x,y) || inPalace(SIDE.HAN,x,y);
  }
  function palaceDiagonalConnected(x1,y1,x2,y2){
    const key = (x,y)=> `${x},${y}`;
    const edges = new Set([
      `${key(3,0)}>${key(4,1)}`, `${key(4,1)}>${key(5,2)}`,
      `${key(5,0)}>${key(4,1)}`, `${key(4,1)}>${key(3,2)}`,
      `${key(3,7)}>${key(4,8)}`, `${key(4,8)}>${key(5,9)}`,
      `${key(5,7)}>${key(4,8)}`, `${key(4,8)}>${key(3,9)}`
    ]);
    const a = `${key(x1,y1)}>${key(x2,y2)}`;
    const b = `${key(x2,y2)}>${key(x1,y1)}`;
    return edges.has(a) || edges.has(b);
  }

  function palaceNeighbors(cx,cy){
    const out=[];
    const cand = [
      [cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1],
      [cx+1,cy+1],[cx-1,cy+1],[cx+1,cy-1],[cx-1,cy-1]
    ];
    for(const [nx,ny] of cand){
      if(!inside(nx,ny)) continue;

      const sameCho = inPalace(SIDE.CHO,cx,cy) && inPalace(SIDE.CHO,nx,ny);
      const sameHan = inPalace(SIDE.HAN,cx,cy) && inPalace(SIDE.HAN,nx,ny);
      if(!sameCho && !sameHan) continue;

      const manhattan = Math.abs(nx-cx)+Math.abs(ny-cy);
      if(manhattan===1) out.push([nx,ny]);
      else if(Math.abs(nx-cx)===1 && Math.abs(ny-cy)===1 && palaceDiagonalConnected(cx,cy,nx,ny)) out.push([nx,ny]);
    }
    return out;
  }

  function palaceRayFrom(x,y,nx0,ny0){
    const ray=[];
    let px=x, py=y;
    let cx=nx0, cy=ny0;
    const vx = cx-px, vy = cy-py;

    while(true){
      ray.push([cx,cy]);

      const nxt = palaceNeighbors(cx,cy).filter(([ax,ay]) => !(ax===px && ay===py));
      const keep = nxt.find(([ax,ay]) => (ax-cx)===vx && (ay-cy)===vy);
      if(!keep) break;

      px=cx; py=cy;
      cx=keep[0]; cy=keep[1];
    }
    return ray;
  }

  // -------------------------
  // Move generation (pseudo)
  // -------------------------
  function genMovesForPiece(b, x,y){
    const p = b[y][x];
    if(!p) return [];
    const side = p.side, t = p.type;
    const moves = [];
    const add = (nx,ny) => {
      if(!inside(nx,ny)) return;
      const q = b[ny][nx];
      if(q && q.side===side) return;
      moves.push({fx:x, fy:y, tx:nx, ty:ny});
    };

    if(t===TYPE.R){
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        let nx=x+dx, ny=y+dy;
        while(inside(nx,ny)){
          const q = b[ny][nx];
          if(!q) moves.push({fx:x,fy:y,tx:nx,ty:ny});
          else { if(q.side!==side) moves.push({fx:x,fy:y,tx:nx,ty:ny}); break; }
          nx+=dx; ny+=dy;
        }
      }
      if(inAnyPalace(x,y)){
        const neigh = palaceNeighbors(x,y);
        for(const [nx0,ny0] of neigh){
          if(Math.abs(nx0-x)===1 && Math.abs(ny0-y)===1 && palaceDiagonalConnected(x,y,nx0,ny0)){
            const ray = palaceRayFrom(x,y,nx0,ny0);
            for(const [nx,ny] of ray){
              const q = b[ny][nx];
              if(!q) moves.push({fx:x,fy:y,tx:nx,ty:ny});
              else { if(q.side!==side) moves.push({fx:x,fy:y,tx:nx,ty:ny}); break; }
            }
          }
        }
      }
    }
    else if(t===TYPE.C){
      function raycastLine(cells){
        let seenScreen = false;
        for(const [nx,ny] of cells){
          const q = b[ny][nx];

          if(!seenScreen){
            if(!q) continue;
            seenScreen = true;
            if(q.type===TYPE.C) return; // 스크린이 포면 불가
            continue;
          }

          if(!q){
            moves.push({fx:x,fy:y,tx:nx,ty:ny});
            continue;
          }else{
            if(q.side!==side && q.type!==TYPE.C) moves.push({fx:x,fy:y,tx:nx,ty:ny});
            return;
          }
        }
      }

      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        const cells=[];
        let nx=x+dx, ny=y+dy;
        while(inside(nx,ny)){ cells.push([nx,ny]); nx+=dx; ny+=dy; }
        raycastLine(cells);
      }

      if(inAnyPalace(x,y)){
        const neigh = palaceNeighbors(x,y);
        for(const [nx0,ny0] of neigh){
          if(Math.abs(nx0-x)===1 && Math.abs(ny0-y)===1 && palaceDiagonalConnected(x,y,nx0,ny0)){
            const cells = palaceRayFrom(x,y,nx0,ny0);
            raycastLine(cells);
          }
        }
      }
    }
    else if(t===TYPE.H){
      const steps = [
        {b:[1,0], d:[1,1]}, {b:[1,0], d:[1,-1]},
        {b:[-1,0], d:[-1,1]}, {b:[-1,0], d:[-1,-1]},
        {b:[0,1], d:[1,1]}, {b:[0,1], d:[-1,1]},
        {b:[0,-1], d:[1,-1]}, {b:[0,-1], d:[-1,-1]},
      ];
      for(const s of steps){
        const bx=x+s.b[0], by=y+s.b[1];
        if(!inside(bx,by)) continue;
        if(b[by][bx]) continue;
        add(x+s.b[0]+s.d[0], y+s.b[1]+s.d[1]);
      }
    }
    else if(t===TYPE.E){
      const patterns = [
        {b1:[1,0], b2:[2,1], to:[3,2]},
        {b1:[1,0], b2:[2,-1], to:[3,-2]},
        {b1:[-1,0], b2:[-2,1], to:[-3,2]},
        {b1:[-1,0], b2:[-2,-1], to:[-3,-2]},
        {b1:[0,1], b2:[1,2], to:[2,3]},
        {b1:[0,1], b2:[-1,2], to:[-2,3]},
        {b1:[0,-1], b2:[1,-2], to:[2,-3]},
        {b1:[0,-1], b2:[-1,-2], to:[-2,-3]},
      ];
      for(const ptn of patterns){
        const b1x=x+ptn.b1[0], b1y=y+ptn.b1[1];
        const b2x=x+ptn.b2[0], b2y=y+ptn.b2[1];
        const tx=x+ptn.to[0], ty=y+ptn.to[1];
        if(!inside(tx,ty) || !inside(b1x,b1y) || !inside(b2x,b2y)) continue;
        if(b[b1y][b1x]) continue;
        if(b[b2y][b2x]) continue;
        add(tx,ty);
      }
    }
    else if(t===TYPE.G || t===TYPE.A){
      const cand = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for(const [dx,dy] of cand){
        const nx=x+dx, ny=y+dy;
        if(!inside(nx,ny)) continue;
        if(!inPalace(side, nx,ny)) continue;
        if(Math.abs(dx)+Math.abs(dy)===2){
          if(!palaceDiagonalConnected(x,y,nx,ny)) continue;
        }
        add(nx,ny);
      }
    }
    else if(t===TYPE.S){
      const dir = (side===SIDE.HAN) ? -1 : 1;
      add(x, y+dir);
      add(x-1, y);
      add(x+1, y);

      const nx1=x-1, ny1=y+dir;
      const nx2=x+1, ny2=y+dir;
      if(inside(nx1,ny1) && inPalace(side, x,y) && inPalace(side, nx1,ny1) && palaceDiagonalConnected(x,y,nx1,ny1)) add(nx1,ny1);
      if(inside(nx2,ny2) && inPalace(side, x,y) && inPalace(side, nx2,ny2) && palaceDiagonalConnected(x,y,nx2,ny2)) add(nx2,ny2);
    }

    return moves;
  }

  function genAllMovesPseudo(b, side){
    const out=[];
    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p=b[y][x];
        if(!p || p.side!==side) continue;
        out.push(...genMovesForPiece(b,x,y));
      }
    }
    return out;
  }

  function cloneBoard(b){
    const nb = [];
    for(let y=0;y<10;y++){
      const row=[];
      for(let x=0;x<9;x++){
        const p=b[y][x];
        row.push(p ? {side:p.side, type:p.type} : null);
      }
      nb.push(row);
    }
    return nb;
  }

  function applyMove(b, mv){
    const nb = cloneBoard(b);
    const p = nb[mv.fy][mv.fx];
    const cap = nb[mv.ty][mv.tx];
    nb[mv.fy][mv.fx]=null;
    nb[mv.ty][mv.tx]=p;
    return { nb, captured: cap };
  }

  function winnerByGeneralMissing(b){
    let hasHanG=false, hasChoG=false;
    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p=b[y][x];
        if(!p) continue;
        if(p.type===TYPE.G){
          if(p.side===SIDE.HAN) hasHanG=true; else hasChoG=true;
        }
      }
    }
    if(!hasChoG) return SIDE.HAN;
    if(!hasHanG) return SIDE.CHO;
    return null;
  }

  // -------------------------
  // Check / Legal move filtering
  // -------------------------
  function findGeneral(b, side){
    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p=b[y][x];
        if(p && p.side===side && p.type===TYPE.G) return {x,y};
      }
    }
    return null;
  }

  function isInCheck(b, defenderSide){
    const gpos = findGeneral(b, defenderSide);
    if(!gpos) return false;
    const attacker = (defenderSide===SIDE.HAN) ? SIDE.CHO : SIDE.HAN;
    const moves = genAllMovesPseudo(b, attacker);
    return moves.some(m => m.tx===gpos.x && m.ty===gpos.y);
  }

  function genAllLegalMoves(b, side){
    const pseudo = genAllMovesPseudo(b, side);
    const legal = [];
    for(const mv of pseudo){
      const {nb} = applyMove(b, mv);
      if(!isInCheck(nb, side)) legal.push(mv);
    }
    return legal;
  }

  function genLegalMovesForPiece(b, x,y){
    const p = b[y][x];
    if(!p) return [];
    const pseudo = genMovesForPiece(b, x,y);
    const legal = [];
    for(const mv of pseudo){
      const {nb} = applyMove(b, mv);
      if(!isInCheck(nb, p.side)) legal.push(mv);
    }
    return legal;
  }

  function checkMateStatus(b, sideToMove){
    const legal = genAllLegalMoves(b, sideToMove);
    if(legal.length > 0) return { mate:false, stalemate:false, legalCount: legal.length };
    const inCheck = isInCheck(b, sideToMove);
    return { mate: inCheck, stalemate: !inCheck, legalCount: 0 };
  }

  // -------------------------
  // Toast (중앙 표시)
  // -------------------------
  let toastTimer = null;
  function showToast(mainText, subText){
    UI.toastText.textContent = mainText;
    UI.toastSub.textContent = subText || "—";
    UI.toast.classList.remove('show');
    void UI.toast.offsetWidth;
    UI.toast.classList.add('show');
    if(toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(()=> UI.toast.classList.remove('show'), 980);
  }

  function showJanggun(attackerSide){
    if(gameOver) return;
    const who = (attackerSide===SIDE.HAN) ? "漢(플레이어)" : "楚(AI)";
    showToast("장군!", who);
    playJanggun();
  }

  function showMate(winnerSide){
    const who = (winnerSide===SIDE.HAN) ? "漢(플레이어)" : "楚(AI)";
    showToast("외통수!", who);
    playJanggun();
  }

  // -------------------------
  // AI (강화: 반복깊이 + 시간제한)
  // -------------------------
  function evaluate(b){
    // + 점수 = 楚 유리, - 점수 = 漢 유리
    let score=0;

    const hanG = findGeneral(b, SIDE.HAN);
    const choG = findGeneral(b, SIDE.CHO);

    let choMob=0, hanMob=0;

    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p=b[y][x];
        if(!p) continue;

        const v = PIECE_VALUE[p.type] || 0;
        score += (p.side===SIDE.CHO) ? v : -v;

        // 졸 전진/압박 보너스 (초는 아래로 전진)
        if(p.type===TYPE.S){
          const adv = (p.side===SIDE.CHO) ? y : (9-y);
          score += (p.side===SIDE.CHO) ? adv*4 : -adv*4;
        }

        // 궁 주변 수비/침투 약간 가중
        const inP = inAnyPalace(x,y);
        if(inP){
          // 초가 한 궁에 침투하면 +, 한이 초 궁에 침투하면 -
          const inChoPal = inPalace(SIDE.CHO,x,y);
          const inHanPal = inPalace(SIDE.HAN,x,y);
          if(inChoPal) score += (p.side===SIDE.CHO) ? 12 : -10;
          if(inHanPal) score += (p.side===SIDE.CHO) ? 10 : -12;
        }

        // 장(왕) 근처 위험/수비
        if(p.type!==TYPE.G){
          if(choG){
            const d = Math.abs(x-choG.x)+Math.abs(y-choG.y);
            if(p.side===SIDE.CHO) score += Math.max(0, 6 - d); // 내 왕 근처 수비
            else score -= Math.max(0, 6 - d); // 적이 내 왕 근처면 위험
          }
          if(hanG){
            const d = Math.abs(x-hanG.x)+Math.abs(y-hanG.y);
            if(p.side===SIDE.HAN) score -= Math.max(0, 6 - d);
            else score += Math.max(0, 6 - d);
          }
        }
      }
    }

    // 기동성(너무 비싸면 느려지니 약하게)
    choMob = genAllLegalMoves(b, SIDE.CHO).length;
    hanMob = genAllLegalMoves(b, SIDE.HAN).length;
    score += (choMob - hanMob) * 1.2;

    // 체크 보너스/패널티
    if(isInCheck(b, SIDE.HAN)) score += 42;
    if(isInCheck(b, SIDE.CHO)) score -= 42;

    return score;
  }

  // 간단 해시(반복깊이 중 동일 포지션 중복 완화)
  function boardKey(b, sideToMove){
    let s = sideToMove + "|";
    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p=b[y][x];
        if(!p) { s += ".."; continue; }
        s += p.side + p.type;
      }
    }
    return s;
  }

  function pickMoveAI(){
    const diff = getDifficulty(winStreak);
    const start = performance.now();
    const timeLimit = diff.timeMs;

    const rootMoves = genAllLegalMoves(board, SIDE.CHO);
    if(rootMoves.length===0) return null;

    // 캡쳐 우선 정렬
    rootMoves.sort((a,b)=> {
      const ca = board[a.ty][a.tx];
      const cb = board[b.ty][b.tx];
      const va = ca ? (PIECE_VALUE[ca.type]||0) : 0;
      const vb = cb ? (PIECE_VALUE[cb.type]||0) : 0;
      return vb - va;
    });

    const TT = new Map(); // key -> {depth, val}
    let bestMove = rootMoves[0];
    let bestVal = -Infinity;

    function alphabeta(b, depth, alpha, beta, maximizing, sideToMove){
      if(performance.now() - start > timeLimit) return evaluate(b);

      const winner = winnerByGeneralMissing(b);
      if(winner===SIDE.CHO) return  999999;
      if(winner===SIDE.HAN) return -999999;

      const st = checkMateStatus(b, sideToMove);
      if(st.mate){
        return (sideToMove === SIDE.CHO) ? -999999 : 999999;
      }
      if(st.stalemate) return 0;

      if(depth===0) return evaluate(b);

      const k = boardKey(b, sideToMove);
      const hit = TT.get(k);
      if(hit && hit.depth >= depth) return hit.val;

      const moves = genAllLegalMoves(b, sideToMove);
      if(moves.length===0) return evaluate(b);

      // move ordering: 캡쳐 우선
      moves.sort((m1,m2)=>{
        const c1 = b[m1.ty][m1.tx];
        const c2 = b[m2.ty][m2.tx];
        const v1 = c1 ? (PIECE_VALUE[c1.type]||0) : 0;
        const v2 = c2 ? (PIECE_VALUE[c2.type]||0) : 0;
        return v2 - v1;
      });

      let val;
      if(maximizing){
        val = -Infinity;
        for(const mv of moves){
          const {nb} = applyMove(b,mv);
          const nxtSide = (sideToMove===SIDE.CHO) ? SIDE.HAN : SIDE.CHO;
          val = Math.max(val, alphabeta(nb, depth-1, alpha, beta, false, nxtSide));
          alpha = Math.max(alpha, val);
          if(beta <= alpha) break;
        }
      }else{
        val = Infinity;
        for(const mv of moves){
          const {nb} = applyMove(b,mv);
          const nxtSide = (sideToMove===SIDE.CHO) ? SIDE.HAN : SIDE.CHO;
          val = Math.min(val, alphabeta(nb, depth-1, alpha, beta, true, nxtSide));
          beta = Math.min(beta, val);
          if(beta <= alpha) break;
        }
      }

      TT.set(k, {depth, val});
      return val;
    }

    // ✅ 반복깊이(Iterative Deepening): 시간 허용하는 만큼 depth를 계속 올림
    // depthCap은 연승에 따라 무한 상승(상한 14로 브라우저 보호)
    for(let depth=2; depth<=diff.depthCap; depth++){
      if(performance.now() - start > timeLimit) break;

      let localBest = bestMove;
      let localBestVal = -Infinity;

      for(const mv of rootMoves){
        if(performance.now() - start > timeLimit) break;
        const {nb} = applyMove(board, mv);
        const sc = alphabeta(nb, depth-1, -Infinity, Infinity, false, SIDE.HAN);

        // 초반만 약간 흔들림, 레벨 오르면 0에 수렴
        const noisy = sc + (diff.noise>0 ? (Math.random()*2-1) * diff.noise * 180 : 0);

        if(noisy > localBestVal){
          localBestVal = noisy;
          localBest = mv;
        }
      }

      // 이번 depth 결과를 채택(시간 내에서 가장 깊은 결과가 남음)
      bestMove = localBest;
      bestVal = localBestVal;
    }

    return bestMove;
  }

  // -------------------------
  // Piece Images (SVG)
  // -------------------------
  const pieceImgCache = new Map();
  const chipImgCache = new Map();

  function getPieceImage(p){
    const key = `${p.side}_${p.type}`;
    if(pieceImgCache.has(key)) return pieceImgCache.get(key);

    const txt = pieceText(p);
    const isHan = p.side === SIDE.HAN;

    const main = getComputedStyle(document.documentElement).getPropertyValue(isHan ? '--blue' : '--red').trim();
    const main2 = getComputedStyle(document.documentElement).getPropertyValue(isHan ? '--blue2' : '--red2').trim();

    const fs = pieceFontSize(p.type);
    const y = (p.type === TYPE.G) ? 112 : 106;

    const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="180" height="180">
      <defs>
        <radialGradient id="stone" cx="35%" cy="30%" r="75%">
          <stop offset="0%" stop-color="#fff7ea"/>
          <stop offset="60%" stop-color="#efe3cf"/>
          <stop offset="100%" stop-color="#cdbfa8"/>
        </radialGradient>
        <radialGradient id="rim" cx="35%" cy="30%" r="75%">
          <stop offset="0%" stop-color="${main2}" stop-opacity="0.65"/>
          <stop offset="100%" stop-color="${main}" stop-opacity="0.95"/>
        </radialGradient>
        <filter id="shadow" x="-30%" y="-30%" width="160%" height="160%">
          <feDropShadow dx="0" dy="10" stdDeviation="8" flood-color="rgba(0,0,0,.28)"/>
        </filter>
      </defs>

      <g filter="url(#shadow)">
        <circle cx="90" cy="94" r="70" fill="rgba(0,0,0,.12)"/>
        <circle cx="90" cy="90" r="70" fill="url(#stone)" stroke="url(#rim)" stroke-width="8"/>
        <circle cx="90" cy="90" r="61" fill="none" stroke="rgba(0,0,0,.10)" stroke-width="2"/>
        <circle cx="90" cy="90" r="66" fill="none" stroke="rgba(255,255,255,.30)" stroke-width="2"/>
        <text x="90" y="${y}" text-anchor="middle" font-size="${fs}" font-weight="900"
          fill="${main}"
          style="paint-order: stroke; stroke: rgba(255,255,255,.55); stroke-width: 3px;"
          font-family="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace">${txt}</text>
      </g>
    </svg>`.trim();

    const img = new Image();
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    pieceImgCache.set(key, img);
    return img;
  }

  function getChipURI(p){
    const key = `${p.side}_${p.type}`;
    if(chipImgCache.has(key)) return chipImgCache.get(key);

    const txt = pieceText(p);
    const isHan = p.side === SIDE.HAN;

    const main = getComputedStyle(document.documentElement).getPropertyValue(isHan ? '--blue' : '--red').trim();
    const fs = chipFontSize(p.type);
    const y = (p.type === TYPE.G) ? 40 : 38;

    const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60">
      <defs>
        <radialGradient id="s" cx="35%" cy="30%" r="75%">
          <stop offset="0%" stop-color="#fff7ea"/>
          <stop offset="60%" stop-color="#efe3cf"/>
          <stop offset="100%" stop-color="#cdbfa8"/>
        </radialGradient>
      </defs>
      <circle cx="30" cy="31" r="23" fill="rgba(0,0,0,.14)"/>
      <circle cx="30" cy="30" r="23" fill="url(#s)" stroke="${main}" stroke-width="3"/>
      <text x="30" y="${y}" text-anchor="middle" font-size="${fs}" font-weight="900" fill="${main}"
        style="paint-order:stroke;stroke:rgba(255,255,255,.55);stroke-width:1.7px;"
        font-family="ui-monospace, monospace">${txt}</text>
    </svg>`.trim();

    const uri = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    chipImgCache.set(key, uri);
    return uri;
  }

  function renderCaptured(){
    UI.capHan.innerHTML = "";
    UI.capCho.innerHTML = "";
    UI.capHanCount.textContent = String(capturedByHan.length);
    UI.capChoCount.textContent = String(capturedByCho.length);

    for(const p of capturedByHan.slice(-24)){
      const div = document.createElement('div');
      div.className = "capChip";
      const img = document.createElement('img');
      img.src = getChipURI(p);
      img.alt = pieceText(p);
      div.appendChild(img);
      UI.capHan.appendChild(div);
    }
    for(const p of capturedByCho.slice(-24)){
      const div = document.createElement('div');
      div.className = "capChip";
      const img = document.createElement('img');
      img.src = getChipURI(p);
      img.alt = pieceText(p);
      div.appendChild(img);
      UI.capCho.appendChild(div);
    }
  }

  // -------------------------
  // Particles
  // -------------------------
  let particles = [];
  let lastTime = performance.now();
  let animT = 0;

  function spawnBurst(x,y,isWin,mega=false){
    const count = mega ? 160 : (isWin ? 120 : 75);
    for(let i=0;i<count;i++){
      const ang = Math.random()*Math.PI*2;
      const spd = (mega?3.2:(isWin?2.8:2.2)) + Math.random()*(mega?4.4:3.6);
      const vx = Math.cos(ang)*spd;
      const vy = Math.sin(ang)*spd - (isWin ? (1.2+Math.random()*1.6) : 0.7);
      const life = (mega?1250:(isWin?980:820)) + Math.random()*(mega?900:700);
      const size = (mega?3.6:(isWin?3.2:2.8)) + Math.random()*2.4;
      particles.push({x,y,vx,vy,life,maxLife:life,size,win:isWin,mega});
    }
  }
  function fireResultParticles(isWin, mega=false){
    const c = xyToPx(4,4.5);
    const bursts = mega ? 9 : (isWin ? 6 : 3);
    for(let b=0;b<bursts;b++){
      spawnBurst(
        c.px + (Math.random()*2-1)*(mega?180:140),
        c.py + (Math.random()*2-1)*(mega?210:160),
        isWin,
        mega
      );
    }
  }

  // -------------------------
  // Smooth move animation
  // -------------------------
  let movingPiece = null;
  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
  function startMoveAnimation(piece, fx,fy, tx,ty){
    const dx = tx - fx, dy = ty - fy;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const dur = Math.max(140, Math.min(300, 140 + dist*60));
    movingPiece = { piece, fx,fy, tx,ty, start: performance.now(), dur };
  }

  // -------------------------
  // Gameplay
  // -------------------------
  function isPlayersTurn(){ return turn===SIDE.HAN && !gameOver && !thinking && !movingPiece; }

  function selectAt(x,y){
    selected = {x,y};
    legalCache = genLegalMovesForPiece(board,x,y);
  }

  function doMove(mv){
    if(gameOver) return;
    if(movingPiece) return;

    const piece = board[mv.fy][mv.fx];
    const cap = board[mv.ty][mv.tx];

    board[mv.fy][mv.fx] = null;
    board[mv.ty][mv.tx] = piece;

    playTak();

    if(cap){
      if(piece.side===SIDE.HAN) capturedByHan.push(cap);
      else capturedByCho.push(cap);
      renderCaptured();
    }

    appendLog(`${piece.side===SIDE.HAN?'漢':'楚'}: ${pieceText(piece)} (${mv.fx},${mv.fy})→(${mv.tx},${mv.ty})` + (cap ? ` [${pieceText(cap)}]` : ""));

    startMoveAnimation(piece, mv.fx, mv.fy, mv.tx, mv.ty);

    const capturedGeneral = (cap && cap.type===TYPE.G);
    const winnerIfAny = capturedGeneral ? piece.side : null;

    const finalize = () => {
      movingPiece = null;
      selected = null;
      legalCache = [];

      if(winnerIfAny){
        appendLog(`${piece.side===SIDE.HAN?'漢':'楚'}: 상대 장을 잡았습니다!`);
        endGame(winnerIfAny, { reason:'capture' });
        return;
      }

      const defender = (piece.side===SIDE.HAN) ? SIDE.CHO : SIDE.HAN;
      if(isInCheck(board, defender)){
        showJanggun(piece.side);
        appendLog(`⚠️ 장군! (${piece.side===SIDE.HAN?'漢':'楚'} → ${defender===SIDE.HAN?'漢':'楚'})`);
      }

      turn = (turn===SIDE.HAN) ? SIDE.CHO : SIDE.HAN;
      syncUI();

      const st = checkMateStatus(board, turn);
      if(st.mate){
        const winner = (turn===SIDE.HAN) ? SIDE.CHO : SIDE.HAN;
        appendLog(`🏁 외통수! (${winner===SIDE.HAN?'漢':'楚'} 승리)`);
        showMate(winner);
        endGame(winner, { reason:'mate' });
        return;
      }
      if(st.stalemate){
        appendLog(`🤝 더 이상 둘 수 있는 수가 없어 무승부!`);
        endGame(null, { reason:'draw' });
        return;
      }

      if(turn===SIDE.CHO){
        thinking = true;
        syncUI();

        const diff = getDifficulty(winStreak);
        setTimeout(() => {
          if(gameOver){ thinking=false; syncUI(); return; }
          const aiMv = pickMoveAI();
          thinking = false;
          syncUI();
          if(gameOver) return;

          if(!aiMv){
            const st2 = checkMateStatus(board, SIDE.CHO);
            if(st2.mate){
              appendLog(`🏁 외통수! (漢 승리)`);
              showMate(SIDE.HAN);
              endGame(SIDE.HAN, { reason:'mate' });
            }else{
              appendLog(`🤝 무승부!`);
              endGame(null, { reason:'draw' });
            }
            return;
          }

          doMove(aiMv);
        }, diff.delayMs);
      }
    };

    setTimeout(finalize, movingPiece.dur);
  }

  function endGame(winner, meta){
    thinking = false;
    gameOver = true;

    UI.fw.classList.remove('on');
    UI.flash.classList.remove('on');

    if(winner === null){
      UI.statusTxt.textContent = "무승부";
      UI.resultTitle.textContent = "무승부";
      UI.resultBody.innerHTML = `더 이상 진행이 불가능합니다.<br/>다시 하려면 <b>다시 하기</b>를 누르세요.`;
      syncUI();
      UI.resultOverlay.classList.add('show');
      return;
    }

    const win = winner === SIDE.HAN;

    if(win){
      winStreak++;
      saveStreak(winStreak);
      UI.statusTxt.textContent = "승리";
      const lv = getDifficulty(winStreak).level;
      if(meta?.reason === 'mate'){
        UI.resultTitle.textContent = "승리! (외통수)";
        UI.resultBody.innerHTML = `상대를 <b>외통수</b>로 제압했습니다!<br/>연승 <b>${winStreak}</b> → 난이도 <b>Lv ${lv}</b>로 상승!`;
      }else{
        UI.resultTitle.textContent = "승리!";
        UI.resultBody.innerHTML = `상대 <b>楚</b>를 잡았습니다.<br/>연승 <b>${winStreak}</b> → 난이도 <b>Lv ${lv}</b>로 상승!`;
      }
      playWin();

      const mega = (meta?.reason === 'mate');
      UI.flash.classList.add('on');
      UI.fw.classList.add('on');
      fireResultParticles(true, mega);
    }else{
      winStreak = 0;
      saveStreak(winStreak);
      UI.statusTxt.textContent = "패배";
      UI.resultTitle.textContent = "패배…";
      UI.resultBody.innerHTML = `내 <b>漢</b>이 잡혔습니다.<br/>연승이 <b>0</b>으로 초기화됩니다.`;
      playLose();
      fireResultParticles(false, false);
    }

    maybeUpdateRecords();
    syncUI();
    UI.resultOverlay.classList.add('show');
  }

  // -------------------------
  // Rendering
  // -------------------------
  function drawBoard(t){
    ctx.clearRect(0,0,cv.width,cv.height);

    const tl = xyToPx(0,0);
    const br = xyToPx(8,9);

    ctx.lineWidth = 5;
    ctx.strokeStyle = "rgba(81,54,31,.75)";
    ctx.beginPath();
    ctx.rect(tl.px, tl.py, br.px - tl.px, br.py - tl.py);
    ctx.stroke();

    ctx.lineWidth = 2;
    for(let x=0;x<9;x++){
      const a = xyToPx(x,0), b = xyToPx(x,9);
      ctx.strokeStyle = "rgba(81,54,31,.48)";
      ctx.beginPath(); ctx.moveTo(a.px,a.py); ctx.lineTo(b.px,b.py); ctx.stroke();
    }
    for(let y=0;y<10;y++){
      const a = xyToPx(0,y), b = xyToPx(8,y);
      ctx.strokeStyle = "rgba(81,54,31,.48)";
      ctx.beginPath(); ctx.moveTo(a.px,a.py); ctx.lineTo(b.px,b.py); ctx.stroke();
    }

    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(81,54,31,.62)";
    const lines = [
      [[3,0],[5,2]], [[5,0],[3,2]],
      [[3,7],[5,9]], [[5,7],[3,9]],
    ];
    for(const [[x1,y1],[x2,y2]] of lines){
      const a=xyToPx(x1,y1), b=xyToPx(x2,y2);
      ctx.beginPath(); ctx.moveTo(a.px,a.py); ctx.lineTo(b.px,b.py); ctx.stroke();
    }

    if(selected){
      for(const m of legalCache){
        const c = xyToPx(m.tx,m.ty);
        ctx.beginPath();
        ctx.fillStyle = "rgba(255, 208, 115, .70)";
        ctx.arc(c.px, c.py, Math.min(cellW,cellH)*0.18, 0, Math.PI*2);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(81,54,31,.35)";
        ctx.stroke();
      }
    }
  }

  function drawPieces(){
    ctx.imageSmoothingEnabled = true;

    let movingDraw = null;
    if(movingPiece){
      const now = performance.now();
      const t = Math.min(1, (now - movingPiece.start) / movingPiece.dur);
      const e = easeOutCubic(t);
      const a = xyToPx(movingPiece.fx, movingPiece.fy);
      const b = xyToPx(movingPiece.tx, movingPiece.ty);
      movingDraw = { piece: movingPiece.piece, x: a.px + (b.px - a.px)*e, y: a.py + (b.py - a.py)*e };
    }

    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p = board[y][x];
        if(!p) continue;
        if(movingPiece && x===movingPiece.tx && y===movingPiece.ty) continue;

        const c = xyToPx(x,y);
        const img = getPieceImage(p);
        const size = Math.min(cellW,cellH) * 0.92;
        if(img.complete) ctx.drawImage(img, c.px - size/2, c.py - size/2, size, size);
      }
    }

    if(movingDraw){
      const img = getPieceImage(movingDraw.piece);
      const size = Math.min(cellW,cellH) * 0.92;
      if(img.complete) ctx.drawImage(img, movingDraw.x - size/2, movingDraw.y - size/2, size, size);
    }

    if(selected){
      const c = xyToPx(selected.x, selected.y);
      ctx.lineWidth = 7;
      ctx.strokeStyle = "rgba(255, 208, 115, .95)";
      ctx.beginPath();
      ctx.arc(c.px, c.py, Math.min(cellW,cellH)*0.48, 0, Math.PI*2);
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(81,54,31,.30)";
      ctx.beginPath();
      ctx.arc(c.px, c.py, Math.min(cellW,cellH)*0.48, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  function drawParticles(dt){
    if(particles.length===0) return;

    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.life -= dt;
      if(p.life <= 0){ particles.splice(i,1); continue; }

      const k = p.life / p.maxLife;
      const a = Math.min(1, k*1.2);

      p.vy += (p.mega?0.014:0.012) * dt;
      p.vx *= 0.999;
      p.vy *= 0.999;
      p.x += p.vx * (dt/16.7);
      p.y += p.vy * (dt/16.7);

      const baseA = (p.mega?1.0:0.9) * a;
      const r = Math.random();
      const col = p.win
        ? (r<0.25 ? `rgba(214,58,43,${baseA})`
            : r<0.50 ? `rgba(30,91,216,${baseA})`
            : r<0.75 ? `rgba(255,208,115,${baseA})`
            : `rgba(57,217,138,${baseA})`)
        : `rgba(0,0,0,${0.18*baseA})`;

      ctx.fillStyle = col;
      const sz = Math.max(2, p.size);
      ctx.fillRect(p.x - sz/2, p.y - sz/2, sz, sz);
    }
  }

  function renderFrame(now){
    const dt = Math.min(40, now - lastTime);
    lastTime = now;
    animT = now;

    drawBoard(animT);
    drawPieces();
    drawParticles(dt);

    requestAnimationFrame(renderFrame);
  }

  // -------------------------
  // UI / Logs / Storage
  // -------------------------
  function appendLog(s){
    UI.log.textContent += (UI.log.textContent ? "\n" : "") + s;
    UI.log.scrollTop = UI.log.scrollHeight;
    UI.logHint.textContent = `${Math.min(UI.log.textContent.split("\n").length, 999)}줄`;
  }

  function syncUI(){
    const diff = getDifficulty(winStreak);
    UI.diffTxt.textContent = `Lv ${diff.level}`;
    UI.streakTxt.textContent = String(winStreak);

    UI.turnTxt.textContent =
      gameOver ? "-" :
      thinking ? `楚(AI) 생각중… (깊이≤${diff.depthCap}, ${diff.timeMs}ms)` :
      (turn===SIDE.HAN ? "漢(플레이어)" : "楚(AI)");

    updateRecordsUI();
  }

  function saveStreak(v){ try{ localStorage.setItem("janggi_streak", String(v)); }catch(e){} }
  function loadStreak(){
    try{
      const v = localStorage.getItem("janggi_streak");
      const n = v ? parseInt(v,10) : 0;
      return Number.isFinite(n) ? n : 0;
    }catch(e){ return 0; }
  }
  function saveBestStreak(v){ try{ localStorage.setItem("janggi_best_streak", String(v)); }catch(e){} }
  function loadBestStreak(){
    try{
      const v = localStorage.getItem("janggi_best_streak");
      const n = v ? parseInt(v,10) : 0;
      return Number.isFinite(n) ? n : 0;
    }catch(e){ return 0; }
  }
  function saveBestDiffLevel(v){ try{ localStorage.setItem("janggi_best_level", String(v)); }catch(e){} }
  function loadBestDiffLevel(){
    try{
      const v = localStorage.getItem("janggi_best_level");
      const n = v ? parseInt(v,10) : 1;
      return Number.isFinite(n) ? Math.max(1,n) : 1;
    }catch(e){ return 1; }
  }

  // -------------------------
  // Input
  // -------------------------
  function handleTap(ev){
    if(!isPlayersTurn()) return;

    const rect = cv.getBoundingClientRect();
    const scaleX = cv.width / rect.width;
    const scaleY = cv.height / rect.height;
    const px = (ev.clientX - rect.left) * scaleX;
    const py = (ev.clientY - rect.top) * scaleY;

    const cell = pxToXY(px,py);
    if(!cell) return;

    const {x,y} = cell;
    const p = get(x,y);

    if(selected){
      const mv = legalCache.find(m => m.tx===x && m.ty===y);
      if(mv){ doMove(mv); return; }
      if(p && p.side===SIDE.HAN) selectAt(x,y);
      else { selected=null; legalCache=[]; }
    }else{
      if(p && p.side===SIDE.HAN) selectAt(x,y);
    }
  }

  cv.addEventListener('pointerdown', (ev) => {
    ev.preventDefault();
    ensureAudio();
    if(audioCtx && audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    handleTap(ev);
  }, { passive:false });

  // -------------------------
  // Buttons
  // -------------------------
  UI.btnNew.addEventListener('click', () => {
    ensureAudio();
    if(audioCtx && audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    UI.resultOverlay.classList.remove('show');
    placeInitial();
  });

  UI.btnHelp.addEventListener('click', () => UI.helpOverlay.classList.add('show'));
  UI.btnGo.addEventListener('click', () => UI.helpOverlay.classList.remove('show'));
  UI.btnCloseHelp.addEventListener('click', () => UI.helpOverlay.classList.remove('show'));

  UI.btnReset.addEventListener('click', () => {
    winStreak = 0;
    saveStreak(winStreak);
    appendLog("연승 리셋!");
    syncUI();
  });

  UI.btnAgain.addEventListener('click', () => {
    UI.resultOverlay.classList.remove('show');
    placeInitial();
  });
  UI.btnCloseResult.addEventListener('click', () => UI.resultOverlay.classList.remove('show'));

  // -------------------------
  // Start
  // -------------------------
  bestStreak = Math.max(bestStreak, winStreak);
  bestDiffLevel = Math.max(bestDiffLevel, getDifficulty(winStreak).level);
  maybeUpdateRecords();

  placeInitial();
  syncUI();
  renderCaptured();

  requestAnimationFrame((t) => { lastTime=t; requestAnimationFrame(renderFrame); });
})();
</script>
</body>
</html>
