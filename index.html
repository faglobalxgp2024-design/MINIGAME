<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>장기 미니게임 (단일 파일)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1622;
      --ink:#d7e0ea;
      --muted:#91a0b1;
      --line:#2a3a52;
      --accent:#f4d35e;
      --danger:#ff5d5d;
      --good:#56f2a6;
      --shadow: 0 10px 0 rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; }
    body{
      margin:0;
      background: radial-gradient(900px 500px at 50% 0%, #14243a 0%, var(--bg) 60%);
      color:var(--ink);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      letter-spacing: .2px;
      image-rendering: pixelated;
      overflow:hidden;
    }

    .wrap{
      max-width: 1100px;
      margin: 0 auto;
      padding: 14px;
      height: 100%;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap: 14px;
    }
    @media (max-width: 900px){
      body{ overflow:auto; }
      .wrap{ grid-template-columns: 1fr; height:auto; }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 2px solid var(--line);
      border-radius: 14px;
      box-shadow: var(--shadow);
    }
    .boardCard{ padding: 12px; display:flex; align-items:center; justify-content:center; }
    .sideCard{ padding: 12px; display:flex; flex-direction:column; gap: 10px; }

    .title{
      font-size: 16px;
      font-weight: 800;
      display:flex;
      align-items:center;
      gap:8px;
      margin: 0 0 6px 0;
    }
    .badge{
      font-size: 12px;
      padding: 3px 8px;
      border: 2px solid var(--line);
      border-radius: 999px;
      color: var(--muted);
      background: rgba(255,255,255,.03);
    }

    .row{ display:flex; gap:8px; flex-wrap:wrap; }
    .stat{
      flex: 1;
      min-width: 140px;
      padding: 10px;
      background: rgba(0,0,0,.25);
      border: 2px solid var(--line);
      border-radius: 12px;
    }
    .stat .k{ color: var(--muted); font-size: 12px; }
    .stat .v{ font-size: 16px; margin-top: 6px; font-weight: 800; }

    button{
      border: 2px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--ink);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 800;
      cursor:pointer;
      box-shadow: 0 6px 0 rgba(0,0,0,.25);
      transform: translateY(0);
      transition: transform .05s ease;
      font-family: inherit;
      letter-spacing: .2px;
    }
    button:active{ transform: translateY(3px); box-shadow: 0 3px 0 rgba(0,0,0,.25); }
    button.primary{
      border-color: rgba(244,211,94,.5);
      background: rgba(244,211,94,.12);
    }
    button.danger{
      border-color: rgba(255,93,93,.45);
      background: rgba(255,93,93,.10);
    }

    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
      padding: 10px;
      border: 2px dashed rgba(145,160,177,.25);
      border-radius: 12px;
      background: rgba(0,0,0,.18);
    }

    .log{
      flex:1;
      min-height: 180px;
      padding: 10px;
      background: rgba(0,0,0,.25);
      border: 2px solid var(--line);
      border-radius: 12px;
      overflow:auto;
      font-size: 12px;
      line-height: 1.5;
      color: var(--muted);
      white-space: pre-wrap;
    }

    .overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.55);
      padding: 16px;
      z-index: 10;
    }
    .overlay.show{ display:flex; }
    .modal{
      width: min(560px, 100%);
      padding: 14px;
    }
    .modal h2{
      margin: 0 0 8px 0;
      font-size: 18px;
    }
    .modal p{ margin: 0 0 12px 0; color: var(--muted); font-size: 13px; line-height: 1.5; }
    .kbd{
      padding: 2px 6px;
      border: 2px solid var(--line);
      border-radius: 8px;
      background: rgba(0,0,0,.25);
      color: var(--ink);
      font-weight: 800;
      font-size: 12px;
      display:inline-block;
      margin: 0 2px;
    }

    canvas{
      width: min(92vw, 680px);
      height: auto;
      aspect-ratio: 9 / 10;
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      border: 2px solid var(--line);
      touch-action: manipulation;
    }

    .small{ font-size: 11px; color: var(--muted); }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 2px solid var(--line);
      background: rgba(0,0,0,.22);
      font-size: 12px;
      color: var(--muted);
    }
    .dot{ width:8px; height:8px; border-radius:50%; background: var(--muted); display:inline-block; }
    .dot.red{ background: var(--danger); }
    .dot.green{ background: var(--good); }
    .dot.yel{ background: var(--accent); }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card boardCard">
      <canvas id="cv" width="900" height="1000" aria-label="장기판"></canvas>
    </div>

    <div class="card sideCard">
      <div>
        <div class="title">
          장기 미니게임 <span class="badge">single file</span>
        </div>
        <div class="row">
          <div class="stat">
            <div class="k">턴</div>
            <div class="v" id="turnTxt">한(플레이어)</div>
          </div>
          <div class="stat">
            <div class="k">난이도</div>
            <div class="v" id="diffTxt">EASY</div>
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <div class="stat">
            <div class="k">연승</div>
            <div class="v" id="streakTxt">0</div>
          </div>
          <div class="stat">
            <div class="k">상태</div>
            <div class="v" id="statusTxt">준비</div>
          </div>
        </div>
      </div>

      <div class="row">
        <button class="primary" id="btnStart">START</button>
        <button id="btnNew">새 판</button>
        <button class="danger" id="btnReset">연승 리셋</button>
      </div>

      <div class="hint">
        <div class="pill"><span class="dot yel"></span> 규칙: <b>상대 ‘장’을 잡으면 승리</b></div><br/>
        <div style="margin-top:6px;">
          조작: 말 클릭 → 이동 칸 클릭<br/>
          AI 난이도: <b>연승이 올라갈수록</b> 탐색 깊이가 증가<br/>
          (모바일도 탭으로 플레이 가능)
        </div>
      </div>

      <div class="small">수순 로그</div>
      <div class="log" id="log"></div>
    </div>
  </div>

  <div class="overlay show" id="overlay">
    <div class="card modal">
      <h2>시작 준비!</h2>
      <p>
        당신은 <b>한(아래)</b> 입니다. <br/>
        목표는 단순: <b>상대 ‘장’을 잡기</b>.<br/><br/>
        조작은 <span class="kbd">클릭/탭</span> 두 번: 말 선택 → 목적지 선택.
      </p>
      <div class="row">
        <button class="primary" id="btnGo">게임 시작</button>
        <button id="btnClose">닫기</button>
      </div>
      <p class="small" style="margin-top:10px;">
        팁: 초반엔 <b>차/포</b> 라인을 열어두면 유리해요.
      </p>
    </div>
  </div>

<script>
(() => {
  // -------------------------
  // 기본 설정 / 상태
  // -------------------------
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const UI = {
    turnTxt: document.getElementById('turnTxt'),
    diffTxt: document.getElementById('diffTxt'),
    streakTxt: document.getElementById('streakTxt'),
    statusTxt: document.getElementById('statusTxt'),
    log: document.getElementById('log'),
    overlay: document.getElementById('overlay'),
    btnStart: document.getElementById('btnStart'),
    btnNew: document.getElementById('btnNew'),
    btnReset: document.getElementById('btnReset'),
    btnGo: document.getElementById('btnGo'),
    btnClose: document.getElementById('btnClose'),
  };

  const SIDE = { HAN:'H', CHO:'C' }; // 한=플레이어(아래), 초=AI(위)
  const TYPE = { G:'G', A:'A', R:'R', H:'H', E:'E', C:'C', S:'S' }; // 장,사,차,마,상,포,졸

  const PIECE_NAME = {
    [TYPE.G]:'장', [TYPE.A]:'사', [TYPE.R]:'차', [TYPE.H]:'마', [TYPE.E]:'상', [TYPE.C]:'포', [TYPE.S]:'졸'
  };
  const PIECE_VALUE = {
    [TYPE.G]: 100000,
    [TYPE.R]: 900,
    [TYPE.C]: 450,
    [TYPE.H]: 350,
    [TYPE.E]: 300,
    [TYPE.A]: 200,
    [TYPE.S]: 120
  };

  // 10x9 board, y:0(top)~9(bottom), x:0~8
  let board = null;
  let turn = SIDE.HAN;        // 한부터
  let gameOver = false;
  let selected = null;        // {x,y}
  let legalCache = [];        // 선택된 말의 합법수
  let moveHistory = [];       // undo 가능하도록

  let winStreak = loadStreak(); // 연승 저장
  let thinking = false;

  // 좌표/그리드
  const GRID = { cols:9, rows:10 };
  const pad = 40;
  const cellW = (cv.width - pad*2) / (GRID.cols-1);
  const cellH = (cv.height - pad*2) / (GRID.rows-1);

  function xyToPx(x,y){ return { px: pad + x*cellW, py: pad + y*cellH }; }
  function pxToXY(px,py){
    const x = Math.round((px - pad)/cellW);
    const y = Math.round((py - pad)/cellH);
    if(x<0||x>=GRID.cols||y<0||y>=GRID.rows) return null;
    // 클릭이 너무 멀면 무시
    const p = xyToPx(x,y);
    const dx = px - p.px, dy = py - p.py;
    if (dx*dx + dy*dy > (Math.min(cellW,cellH)*0.45)**2) return null;
    return {x,y};
  }

  // -------------------------
  // 난이도(연승 기반)
  // -------------------------
  function getDifficulty(streak){
    // 깊이/시간/노이즈로 난이도 조절
    if(streak <= 0) return { name:'EASY', depth:2, timeMs:220, noise:0.25 };
    if(streak === 1) return { name:'NORMAL', depth:3, timeMs:450, noise:0.14 };
    if(streak === 2) return { name:'HARD', depth:4, timeMs:850, noise:0.08 };
    if(streak === 3) return { name:'PRO', depth:5, timeMs:1300, noise:0.03 };
    return { name:'BOSS', depth:5, timeMs:1700, noise:0.0 };
  }

  // -------------------------
  // 초기 배치 (표준 장기 배치)
  // -------------------------
  function makeEmptyBoard(){
    const b = [];
    for(let y=0;y<10;y++){
      const row = [];
      for(let x=0;x<9;x++) row.push(null);
      b.push(row);
    }
    return b;
  }

  function placeInitial(){
    board = makeEmptyBoard();

    // 초(위)
    put(0,0, SIDE.CHO, TYPE.R); put(8,0, SIDE.CHO, TYPE.R);
    put(1,0, SIDE.CHO, TYPE.H); put(7,0, SIDE.CHO, TYPE.H);
    put(2,0, SIDE.CHO, TYPE.E); put(6,0, SIDE.CHO, TYPE.E);
    put(3,0, SIDE.CHO, TYPE.A); put(5,0, SIDE.CHO, TYPE.A);
    put(4,1, SIDE.CHO, TYPE.G);
    put(1,2, SIDE.CHO, TYPE.C); put(7,2, SIDE.CHO, TYPE.C);
    put(0,3, SIDE.CHO, TYPE.S); put(2,3, SIDE.CHO, TYPE.S); put(4,3, SIDE.CHO, TYPE.S); put(6,3, SIDE.CHO, TYPE.S); put(8,3, SIDE.CHO, TYPE.S);

    // 한(아래)
    put(0,9, SIDE.HAN, TYPE.R); put(8,9, SIDE.HAN, TYPE.R);
    put(1,9, SIDE.HAN, TYPE.H); put(7,9, SIDE.HAN, TYPE.H);
    put(2,9, SIDE.HAN, TYPE.E); put(6,9, SIDE.HAN, TYPE.E);
    put(3,9, SIDE.HAN, TYPE.A); put(5,9, SIDE.HAN, TYPE.A);
    put(4,8, SIDE.HAN, TYPE.G);
    put(1,7, SIDE.HAN, TYPE.C); put(7,7, SIDE.HAN, TYPE.C);
    put(0,6, SIDE.HAN, TYPE.S); put(2,6, SIDE.HAN, TYPE.S); put(4,6, SIDE.HAN, TYPE.S); put(6,6, SIDE.HAN, TYPE.S); put(8,6, SIDE.HAN, TYPE.S);

    turn = SIDE.HAN;
    gameOver = false;
    selected = null;
    legalCache = [];
    moveHistory = [];
    thinking = false;
    UI.statusTxt.textContent = "진행중";
    appendLog("새 판 시작! (한: 플레이어, 초: AI)");
    syncUI();
    draw();
  }

  function put(x,y, side, type){
    board[y][x] = { side, type };
  }

  // -------------------------
  // 궁성/대각선 라인 정의
  // -------------------------
  function inPalace(side, x,y){
    // 초 궁성: x 3..5, y 0..2
    // 한 궁성: x 3..5, y 7..9
    if(x<3||x>5) return false;
    if(side===SIDE.CHO) return (y>=0 && y<=2);
    return (y>=7 && y<=9);
  }

  // 궁성 안에서의 연결(직선/대각선) 허용 포인트들
  // 장기 궁성 대각선은 (3,0)-(4,1)-(5,2) 및 (5,0)-(4,1)-(3,2), 아래도 동일
  function palaceDiagonalConnected(x1,y1,x2,y2){
    const key = (x,y)=> `${x},${y}`;
    const edges = new Set([
      // 위 궁성
      `${key(3,0)}>${key(4,1)}`, `${key(4,1)}>${key(5,2)}`,
      `${key(5,0)}>${key(4,1)}`, `${key(4,1)}>${key(3,2)}`,
      // 아래 궁성
      `${key(3,7)}>${key(4,8)}`, `${key(4,8)}>${key(5,9)}`,
      `${key(5,7)}>${key(4,8)}`, `${key(4,8)}>${key(3,9)}`
    ]);
    const a = `${key(x1,y1)}>${key(x2,y2)}`;
    const b = `${key(x2,y2)}>${key(x1,y1)}`;
    return edges.has(a) || edges.has(b);
  }

  // -------------------------
  // 이동 생성
  // -------------------------
  function inside(x,y){ return x>=0 && x<9 && y>=0 && y<10; }
  function get(x,y){ return board[y][x]; }

  function genMovesForPiece(b, x,y){
    const p = b[y][x];
    if(!p) return [];
    const side = p.side, t = p.type;
    const moves = [];
    const add = (nx,ny) => {
      if(!inside(nx,ny)) return;
      const q = b[ny][nx];
      if(q && q.side===side) return;
      moves.push({fx:x, fy:y, tx:nx, ty:ny});
    };

    if(t===TYPE.R){
      // 차: 직선 무제한, 궁성 대각선 라인도 1칸씩 연결 따라 이동 허용
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        let nx=x+dx, ny=y+dy;
        while(inside(nx,ny)){
          const q = b[ny][nx];
          if(!q){ moves.push({fx:x,fy:y,tx:nx,ty:ny}); }
          else{
            if(q.side!==side) moves.push({fx:x,fy:y,tx:nx,ty:ny});
            break;
          }
          nx+=dx; ny+=dy;
        }
      }
      // 궁성 대각선: 연결선을 따라 진행(여러 칸 가능)
      // BFS처럼 연결선 타고 빈칸 쭉 + 막히면 캡처 가능
      const palaceNodes = [];
      for(let yy=0;yy<10;yy++) for(let xx=0;xx<9;xx++){
        if(inPalace(SIDE.CHO,xx,yy) || inPalace(SIDE.HAN,xx,yy)) palaceNodes.push([xx,yy]);
      }
      const neighbors = (cx,cy)=>{
        const out=[];
        const cand = [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1],[cx+1,cy+1],[cx-1,cy+1],[cx+1,cy-1],[cx-1,cy-1]];
        for(const [nx,ny] of cand){
          if(!inside(nx,ny)) continue;
          const samePal = (inPalace(SIDE.CHO,cx,cy)&&inPalace(SIDE.CHO,nx,ny)) || (inPalace(SIDE.HAN,cx,cy)&&inPalace(SIDE.HAN,nx,ny));
          if(!samePal) continue;
          const manhattan = Math.abs(nx-cx)+Math.abs(ny-cy);
          if(manhattan===1) out.push([nx,ny]);
          else if(Math.abs(nx-cx)===1 && Math.abs(ny-cy)===1 && palaceDiagonalConnected(cx,cy,nx,ny)) out.push([nx,ny]);
        }
        return out;
      };

      if(inPalace(SIDE.CHO,x,y) || inPalace(SIDE.HAN,x,y)){
        // 각 이웃 방향으로 "쭉" 이동
        const neigh = neighbors(x,y);
        for(const [nx0,ny0] of neigh){
          let nx=nx0, ny=ny0;
          let px=x, py=y;
          while(true){
            const q = b[ny][nx];
            if(!q){
              moves.push({fx:x,fy:y,tx:nx,ty:ny});
            }else{
              if(q.side!==side) moves.push({fx:x,fy:y,tx:nx,ty:ny});
              break;
            }
            // 다음으로 같은 방향(연결)을 따라 계속
            const nxt = neighbors(nx,ny).filter(([ax,ay]) => !(ax===px && ay===py));
            // 직전 방향으로만 이어가도록: 후보 중 현재-직전 벡터와 같은 벡터를 우선
            const vx=nx-px, vy=ny-py;
            const keep = nxt.find(([ax,ay]) => (ax-nx)===vx && (ay-ny)===vy);
            if(!keep) break;
            px=nx; py=ny;
            nx=keep[0]; ny=keep[1];
          }
        }
      }
    }

    else if(t===TYPE.C){
      // 포: 직선, 반드시 1개를 뛰어넘어야 이동/캡처 가능
      // 규칙 단순화: 스크린(넘는 말)은 "포가 아니어야" 하고, 잡는 대상도 "포가 아니어야"
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        let nx=x+dx, ny=y+dy;
        // 스크린 찾기
        while(inside(nx,ny) && !b[ny][nx]){ nx+=dx; ny+=dy; }
        if(!inside(nx,ny)) continue;
        const screen = b[ny][nx];
        if(!screen) continue;
        if(screen.type===TYPE.C) continue; // 포는 포를 못 넘김(일반 룰)
        // 스크린 다음부터 착지 가능
        nx+=dx; ny+=dy;
        while(inside(nx,ny)){
          const q = b[ny][nx];
          if(!q){
            moves.push({fx:x,fy:y,tx:nx,ty:ny});
          }else{
            // 캡처: 상대 + 포는 캡처 불가
            if(q.side!==side && q.type!==TYPE.C){
              moves.push({fx:x,fy:y,tx:nx,ty:ny});
            }
            break;
          }
          nx+=dx; ny+=dy;
        }
      }
      // 궁성 대각선 포 이동(스크린 필요)까지는 구현하면 길어져서 1차에선 생략(가볍게)
    }

    else if(t===TYPE.H){
      // 마: (1직 + 1대각), 첫 직선칸이 막히면 불가
      const steps = [
        {b:[1,0], d:[1,1]}, {b:[1,0], d:[1,-1]},
        {b:[-1,0], d:[-1,1]}, {b:[-1,0], d:[-1,-1]},
        {b:[0,1], d:[1,1]}, {b:[0,1], d:[-1,1]},
        {b:[0,-1], d:[1,-1]}, {b:[0,-1], d:[-1,-1]},
      ];
      for(const s of steps){
        const bx=x+s.b[0], by=y+s.b[1];
        if(!inside(bx,by)) continue;
        if(b[by][bx]) continue; // 막힘
        add(x+s.b[0]+s.d[0], y+s.b[1]+s.d[1]);
      }
    }

    else if(t===TYPE.E){
      // 상(코끼리): 1직 + 2대각(총 3스텝), 2개의 막힘 체크
      // 예: 오른쪽(1,0) 후 (1,1) 후 (1,1) => (x+2,y+2)? 실제는 1직 + 2대각이라 최종 (±2,±2) 또는 (±2,∓2)? 아니라 (±3,±2) 같은 변형이 아니라
      // 장기의 상은 (1직) + (1대각) + (1대각) => 최종 (±2,±3) 또는 (±3,±2) 가 아니라 (±2,±3) 형태.
      // 정확 패턴(한국 장기 상):
      //   (±1,0) 막힘, (±2,±1) 막힘, 최종 (±3,±2)
      //   (0,±1) 막힘, (±1,±2) 막힘, 최종 (±2,±3)
      const patterns = [
        {b1:[1,0], b2:[2,1], to:[3,2]},
        {b1:[1,0], b2:[2,-1], to:[3,-2]},
        {b1:[-1,0], b2:[-2,1], to:[-3,2]},
        {b1:[-1,0], b2:[-2,-1], to:[-3,-2]},
        {b1:[0,1], b2:[1,2], to:[2,3]},
        {b1:[0,1], b2:[-1,2], to:[-2,3]},
        {b1:[0,-1], b2:[1,-2], to:[2,-3]},
        {b1:[0,-1], b2:[-1,-2], to:[-2,-3]},
      ];
      for(const ptn of patterns){
        const b1x=x+ptn.b1[0], b1y=y+ptn.b1[1];
        const b2x=x+ptn.b2[0], b2y=y+ptn.b2[1];
        const tx=x+ptn.to[0], ty=y+ptn.to[1];
        if(!inside(tx,ty) || !inside(b1x,b1y) || !inside(b2x,b2y)) continue;
        if(b[b1y][b1x]) continue;
        if(b[b2y][b2x]) continue;
        add(tx,ty);
      }
    }

    else if(t===TYPE.G || t===TYPE.A){
      // 장/사: 궁성 내에서 1칸(직선 + 대각선(연결선))
      const cand = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for(const [dx,dy] of cand){
        const nx=x+dx, ny=y+dy;
        if(!inside(nx,ny)) continue;
        if(!inPalace(side, nx,ny)) continue;
        if(Math.abs(dx)+Math.abs(dy)===2){
          // 대각선은 궁성 연결선일 때만
          if(!palaceDiagonalConnected(x,y,nx,ny)) continue;
        }
        add(nx,ny);
      }
    }

    else if(t===TYPE.S){
      // 졸: 전진 1, 좌우 1. (강 건너 제한 없음)
      const dir = (side===SIDE.HAN) ? -1 : 1; // 한은 위로 전진
      add(x, y+dir);
      add(x-1, y);
      add(x+1, y);

      // 궁성 안에서는 대각 전진도 허용(연결선 기반)
      const nx1=x-1, ny1=y+dir;
      const nx2=x+1, ny2=y+dir;
      if(inside(nx1,ny1) && inPalace(side, x,y) && inPalace(side, nx1,ny1) && palaceDiagonalConnected(x,y,nx1,ny1)) add(nx1,ny1);
      if(inside(nx2,ny2) && inPalace(side, x,y) && inPalace(side, nx2,ny2) && palaceDiagonalConnected(x,y,nx2,ny2)) add(nx2,ny2);
    }

    return moves;
  }

  // 전체 수 생성
  function genAllMoves(b, side){
    const out=[];
    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p=b[y][x];
        if(!p || p.side!==side) continue;
        out.push(...genMovesForPiece(b,x,y));
      }
    }
    return out;
  }

  function cloneBoard(b){
    const nb = [];
    for(let y=0;y<10;y++){
      const row=[];
      for(let x=0;x<9;x++){
        const p=b[y][x];
        row.push(p ? {side:p.side, type:p.type} : null);
      }
      nb.push(row);
    }
    return nb;
  }

  function applyMove(b, mv){
    const nb = cloneBoard(b);
    const p = nb[mv.fy][mv.fx];
    const cap = nb[mv.ty][mv.tx];
    nb[mv.fy][mv.fx]=null;
    nb[mv.ty][mv.tx]=p;
    return { nb, captured: cap };
  }

  function findGeneral(b, side){
    for(let y=0;y<10;y++) for(let x=0;x<9;x++){
      const p=b[y][x];
      if(p && p.side===side && p.type===TYPE.G) return {x,y};
    }
    return null;
  }

  // 간단 승패: 상대 장이 사라지면 끝
  function checkWinnerSimple(b){
    const gH = findGeneral(b, SIDE.HAN);
    const gC = findGeneral(b, SIDE.CHO);
    if(!gC) return SIDE.HAN;
    if(!gH) return SIDE.CHO;
    return null;
  }

  // -------------------------
  // AI (알파베타 미니맥스 + 시간 제한)
  // -------------------------
  function evaluate(b){
    // 큰 값일수록 초(AI)에게 유리한 점수로 통일
    let score=0;
    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p=b[y][x];
        if(!p) continue;
        const v = PIECE_VALUE[p.type] || 0;
        score += (p.side===SIDE.CHO) ? v : -v;

        // 살짝 위치 가중치(졸 전진 유리)
        if(p.type===TYPE.S){
          const adv = (p.side===SIDE.CHO) ? y : (9-y);
          score += (p.side===SIDE.CHO) ? adv*2 : -adv*2;
        }
      }
    }
    return score;
  }

  function pickMoveAI(){
    const diff = getDifficulty(winStreak);
    const start = performance.now();
    const timeLimit = diff.timeMs;

    const side = SIDE.CHO;
    let best = null;
    let bestScore = -Infinity;

    const moves = genAllMoves(board, side);
    if(moves.length===0) return null;

    // move ordering: 캡처 우선
    moves.sort((a,b)=> {
      const ca = board[a.ty][a.tx];
      const cb = board[b.ty][b.tx];
      const va = ca ? (PIECE_VALUE[ca.type]||0) : 0;
      const vb = cb ? (PIECE_VALUE[cb.type]||0) : 0;
      return vb - va;
    });

    const noise = diff.noise;

    function alphabeta(b, depth, alpha, beta, maximizing){
      // 시간 제한 체크
      if(performance.now() - start > timeLimit) return evaluate(b);

      const winner = checkWinnerSimple(b);
      if(winner===SIDE.CHO) return  999999;
      if(winner===SIDE.HAN) return -999999;

      if(depth===0) return evaluate(b);

      const s = maximizing ? SIDE.CHO : SIDE.HAN;
      const ms = genAllMoves(b, s);
      if(ms.length===0) return evaluate(b);

      // ordering (light)
      ms.sort((m1,m2)=>{
        const c1 = b[m1.ty][m1.tx];
        const c2 = b[m2.ty][m2.tx];
        const v1 = c1 ? (PIECE_VALUE[c1.type]||0) : 0;
        const v2 = c2 ? (PIECE_VALUE[c2.type]||0) : 0;
        return v2 - v1;
      });

      if(maximizing){
        let v=-Infinity;
        for(const mv of ms){
          const {nb} = applyMove(b,mv);
          v = Math.max(v, alphabeta(nb, depth-1, alpha, beta, false));
          alpha = Math.max(alpha, v);
          if(beta <= alpha) break;
        }
        return v;
      }else{
        let v=Infinity;
        for(const mv of ms){
          const {nb} = applyMove(b,mv);
          v = Math.min(v, alphabeta(nb, depth-1, alpha, beta, true));
          beta = Math.min(beta, v);
          if(beta <= alpha) break;
        }
        return v;
      }
    }

    for(const mv of moves){
      const {nb} = applyMove(board, mv);
      let sc = alphabeta(nb, diff.depth-1, -Infinity, Infinity, false);

      // 초보 난이도는 약간 랜덤성(상황 따라 블러프 같은 느낌)
      if(noise>0){
        sc += (Math.random()*2-1) * noise * 200;
      }

      if(sc > bestScore){
        bestScore = sc;
        best = mv;
      }
      if(performance.now() - start > timeLimit) break;
    }

    return best;
  }

  // -------------------------
  // 실제 플레이 / 입력
  // -------------------------
  function isPlayersTurn(){ return turn===SIDE.HAN && !gameOver && !thinking; }

  function handleTap(ev){
    if(!isPlayersTurn()) return;

    const rect = cv.getBoundingClientRect();
    const scaleX = cv.width / rect.width;
    const scaleY = cv.height / rect.height;
    const px = (ev.clientX - rect.left) * scaleX;
    const py = (ev.clientY - rect.top) * scaleY;
    const cell = pxToXY(px,py);
    if(!cell) return;

    const {x,y} = cell;
    const p = get(x,y);

    if(selected){
      // 이미 선택된 상태면: 이동 시도 or 다른 말로 재선택
      const mv = legalCache.find(m => m.tx===x && m.ty===y);
      if(mv){
        doMove(mv, true);
        return;
      }
      // 다른 내 말이면 재선택
      if(p && p.side===SIDE.HAN){
        selectAt(x,y);
      }else{
        // 취소
        selected=null; legalCache=[];
        draw();
      }
    }else{
      if(p && p.side===SIDE.HAN){
        selectAt(x,y);
      }
    }
  }

  function selectAt(x,y){
    selected = {x,y};
    const all = genMovesForPiece(board,x,y);
    // 간단 규칙 모드라 체크(장군) 불법수 제거는 생략 가능.
    // 그래도 "자기 말 잡기"는 이미 걸러짐.
    legalCache = all;
    draw();
  }

  function doMove(mv, byPlayer){
    if(gameOver) return;
    const p = board[mv.fy][mv.fx];
    const cap = board[mv.ty][mv.tx];

    // 히스토리 저장
    moveHistory.push({
      board: cloneBoard(board),
      turn,
      streak: winStreak
    });

    board[mv.fy][mv.fx] = null;
    board[mv.ty][mv.tx] = p;

    selected=null; legalCache=[];
    const moverName = (p.side===SIDE.HAN) ? "한" : "초";
    const moveTxt = `${moverName}: ${PIECE_NAME[p.type]} (${mv.fx},${mv.fy})→(${mv.tx},${mv.ty})` + (cap ? `  [${PIECE_NAME[cap.type]} 잡음]` : "");
    appendLog(moveTxt);

    const winner = checkWinnerSimple(board);
    if(winner){
      endGame(winner);
      draw();
      return;
    }

    // 턴 교대
    turn = (turn===SIDE.HAN) ? SIDE.CHO : SIDE.HAN;
    syncUI();
    draw();

    // AI 턴
    if(turn===SIDE.CHO){
      thinking = true;
      syncUI();
      setTimeout(() => {
        const aiMv = pickMoveAI();
        thinking = false;
        if(!aiMv){
          // 이동 불가면 패배 처리(간단)
          endGame(SIDE.HAN);
          draw();
          return;
        }
        doMove(aiMv, false);
      }, 50);
    }
  }

  function endGame(winner){
    gameOver = true;
    const msg = (winner===SIDE.HAN) ? "승리! (상대 장을 잡았습니다)" : "패배… (내 장이 잡혔습니다)";
    appendLog("================================");
    appendLog(msg);

    if(winner===SIDE.HAN){
      winStreak++;
      saveStreak(winStreak);
      UI.statusTxt.textContent = "승리";
    }else{
      winStreak = 0;
      saveStreak(winStreak);
      UI.statusTxt.textContent = "패배";
    }
    syncUI();
  }

  // -------------------------
  // 렌더링
  // -------------------------
  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);

    // 배경 그리드
    ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(42,58,82,.9)";

    // 바깥 선
    ctx.beginPath();
    const tl = xyToPx(0,0);
    const br = xyToPx(8,9);
    ctx.rect(tl.px, tl.py, br.px - tl.px, br.py - tl.py);
    ctx.stroke();

    // 내부 격자선
    ctx.lineWidth = 2;
    for(let x=0;x<9;x++){
      const p1 = xyToPx(x,0), p2 = xyToPx(x,9);
      ctx.beginPath();
      ctx.moveTo(p1.px,p1.py);
      ctx.lineTo(p2.px,p2.py);
      ctx.stroke();
    }
    for(let y=0;y<10;y++){
      const p1 = xyToPx(0,y), p2 = xyToPx(8,y);
      ctx.beginPath();
      ctx.moveTo(p1.px,p1.py);
      ctx.lineTo(p2.px,p2.py);
      ctx.stroke();
    }

    // 궁성 대각선(표시)
    drawPalaceLines();

    // 하이라이트(가능 수)
    if(selected){
      for(const m of legalCache){
        const c = xyToPx(m.tx,m.ty);
        ctx.beginPath();
        ctx.fillStyle = "rgba(244,211,94,.22)";
        ctx.arc(c.px, c.py, Math.min(cellW,cellH)*0.22, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // 말 그리기
    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p = board[y][x];
        if(!p) continue;
        drawPiece(x,y,p);
      }
    }

    // 선택 테두리
    if(selected){
      const c = xyToPx(selected.x, selected.y);
      ctx.lineWidth = 6;
      ctx.strokeStyle = "rgba(244,211,94,.95)";
      ctx.beginPath();
      ctx.arc(c.px,c.py, Math.min(cellW,cellH)*0.36, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  function drawPalaceLines(){
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(145,160,177,.6)";

    const lines = [
      // 위 궁성
      [[3,0],[5,2]], [[5,0],[3,2]],
      // 아래 궁성
      [[3,7],[5,9]], [[5,7],[3,9]],
    ];
    for(const [[x1,y1],[x2,y2]] of lines){
      const a=xyToPx(x1,y1), b=xyToPx(x2,y2);
      ctx.beginPath();
      ctx.moveTo(a.px,a.py);
      ctx.lineTo(b.px,b.py);
      ctx.stroke();
    }
  }

  function drawPiece(x,y,p){
    const c = xyToPx(x,y);
    const r = Math.min(cellW,cellH)*0.34;

    // 바탕 원
    ctx.beginPath();
    ctx.fillStyle = "rgba(0,0,0,.28)";
    ctx.arc(c.px+3,c.py+6,r,0,Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = (p.side===SIDE.HAN) ? "rgba(86,242,166,.18)" : "rgba(255,93,93,.16)";
    ctx.strokeStyle = "rgba(215,224,234,.55)";
    ctx.lineWidth = 4;
    ctx.arc(c.px,c.py,r,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // 글자
    const label = PIECE_NAME[p.type];
    ctx.fillStyle = (p.side===SIDE.HAN) ? "rgba(86,242,166,.95)" : "rgba(255,93,93,.95)";
    ctx.font = `bold ${Math.floor(r*1.15)}px ui-monospace, monospace`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, c.px, c.py+1);
  }

  // -------------------------
  // UI / 로그 / 저장
  // -------------------------
  function appendLog(s){
    UI.log.textContent += (UI.log.textContent ? "\n" : "") + s;
    UI.log.scrollTop = UI.log.scrollHeight;
  }

  function syncUI(){
    const diff = getDifficulty(winStreak);
    UI.turnTxt.textContent =
      gameOver ? "-" :
      thinking ? "초(AI) 생각중…" :
      (turn===SIDE.HAN ? "한(플레이어)" : "초(AI)");

    UI.diffTxt.textContent = diff.name;
    UI.streakTxt.textContent = String(winStreak);

    if(!gameOver && !thinking) UI.statusTxt.textContent = "진행중";
  }

  function saveStreak(v){
    try{ localStorage.setItem("janggi_streak", String(v)); }catch(e){}
  }
  function loadStreak(){
    try{
      const v = localStorage.getItem("janggi_streak");
      const n = v ? parseInt(v,10) : 0;
      return Number.isFinite(n) ? n : 0;
    }catch(e){ return 0; }
  }

  // -------------------------
  // 버튼 / 오버레이
  // -------------------------
  UI.btnStart.addEventListener('click', () => {
    UI.overlay.classList.add('show');
  });
  UI.btnGo.addEventListener('click', () => {
    UI.overlay.classList.remove('show');
    if(!board) placeInitial();
  });
  UI.btnClose.addEventListener('click', () => UI.overlay.classList.remove('show'));

  UI.btnNew.addEventListener('click', () => placeInitial());
  UI.btnReset.addEventListener('click', () => {
    winStreak = 0;
    saveStreak(winStreak);
    appendLog("연승 리셋!");
    syncUI();
    draw();
  });

  // 입력
  cv.addEventListener('pointerdown', (ev) => handleTap(ev));

  // 첫 화면
  syncUI();
  placeInitial();
})();
</script>
</body>
</html>
