<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>장기 미니게임 (단일 파일)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1622;
      --ink:#d7e0ea;
      --muted:#91a0b1;
      --line:#2a3a52;
      --accent:#f4d35e;
      --danger:#ff5d5d;
      --good:#56f2a6;
      --shadow: 0 10px 0 rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; }
    body{
      margin:0;
      background: radial-gradient(900px 500px at 50% 0%, #14243a 0%, var(--bg) 60%);
      color:var(--ink);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      letter-spacing: .2px;
      image-rendering: pixelated;
      overflow:hidden;
      overscroll-behavior: none;
    }

    .wrap{
      max-width: 1100px;
      margin: 0 auto;
      padding: 14px;
      height: 100%;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap: 14px;
    }
    @media (max-width: 900px){
      body{ overflow:auto; }
      .wrap{ grid-template-columns: 1fr; height:auto; }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 2px solid var(--line);
      border-radius: 14px;
      box-shadow: var(--shadow);
    }
    .boardCard{ padding: 12px; display:flex; align-items:center; justify-content:center; }
    .sideCard{ padding: 12px; display:flex; flex-direction:column; gap: 10px; }

    .title{
      font-size: 16px;
      font-weight: 800;
      display:flex;
      align-items:center;
      gap:8px;
      margin: 0 0 6px 0;
    }
    .badge{
      font-size: 12px;
      padding: 3px 8px;
      border: 2px solid var(--line);
      border-radius: 999px;
      color: var(--muted);
      background: rgba(255,255,255,.03);
    }

    .row{ display:flex; gap:8px; flex-wrap:wrap; }
    .stat{
      flex: 1;
      min-width: 140px;
      padding: 10px;
      background: rgba(0,0,0,.25);
      border: 2px solid var(--line);
      border-radius: 12px;
    }
    .stat .k{ color: var(--muted); font-size: 12px; }
    .stat .v{ font-size: 16px; margin-top: 6px; font-weight: 800; }

    button{
      border: 2px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--ink);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 800;
      cursor:pointer;
      box-shadow: 0 6px 0 rgba(0,0,0,.25);
      transform: translateY(0);
      transition: transform .05s ease;
      font-family: inherit;
      letter-spacing: .2px;
    }
    button:active{ transform: translateY(3px); box-shadow: 0 3px 0 rgba(0,0,0,.25); }
    button.primary{
      border-color: rgba(244,211,94,.5);
      background: rgba(244,211,94,.12);
    }
    button.danger{
      border-color: rgba(255,93,93,.45);
      background: rgba(255,93,93,.10);
    }

    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
      padding: 10px;
      border: 2px dashed rgba(145,160,177,.25);
      border-radius: 12px;
      background: rgba(0,0,0,.18);
    }

    .log{
      flex:1;
      min-height: 180px;
      padding: 10px;
      background: rgba(0,0,0,.25);
      border: 2px solid var(--line);
      border-radius: 12px;
      overflow:auto;
      font-size: 12px;
      line-height: 1.5;
      color: var(--muted);
      white-space: pre-wrap;
    }

    .overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.55);
      padding: 16px;
      z-index: 10;
    }
    .overlay.show{ display:flex; }
    .modal{
      width: min(560px, 100%);
      padding: 14px;
    }
    .modal h2{
      margin: 0 0 8px 0;
      font-size: 18px;
    }
    .modal p{ margin: 0 0 12px 0; color: var(--muted); font-size: 13px; line-height: 1.5; }
    .kbd{
      padding: 2px 6px;
      border: 2px solid var(--line);
      border-radius: 8px;
      background: rgba(0,0,0,.25);
      color: var(--ink);
      font-weight: 800;
      font-size: 12px;
      display:inline-block;
      margin: 0 2px;
    }

    canvas{
      width: min(92vw, 680px);
      height: auto;
      aspect-ratio: 9 / 10;
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      border: 2px solid var(--line);

      /* ✅ 스크롤/줌/페이지 이동 방지 */
      touch-action: none;
      user-select: none;
    }

    .small{ font-size: 11px; color: var(--muted); }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 2px solid var(--line);
      background: rgba(0,0,0,.22);
      font-size: 12px;
      color: var(--muted);
    }
    .dot{ width:8px; height:8px; border-radius:50%; background: var(--muted); display:inline-block; }
    .dot.red{ background: var(--danger); }
    .dot.green{ background: var(--good); }
    .dot.yel{ background: var(--accent); }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card boardCard">
      <canvas id="cv" width="900" height="1000" aria-label="장기판"></canvas>
    </div>

    <div class="card sideCard">
      <div>
        <div class="title">
          장기 미니게임 <span class="badge">single file</span>
        </div>
        <div class="row">
          <div class="stat">
            <div class="k">턴</div>
            <div class="v" id="turnTxt">한(플레이어)</div>
          </div>
          <div class="stat">
            <div class="k">난이도</div>
            <div class="v" id="diffTxt">EASY</div>
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <div class="stat">
            <div class="k">연승</div>
            <div class="v" id="streakTxt">0</div>
          </div>
          <div class="stat">
            <div class="k">상태</div>
            <div class="v" id="statusTxt">준비</div>
          </div>
        </div>
      </div>

      <div class="row">
        <button class="primary" id="btnStart">START</button>
        <button id="btnNew">새 판</button>
        <button class="danger" id="btnReset">연승 리셋</button>
      </div>

      <div class="hint">
        <div class="pill"><span class="dot yel"></span> 규칙: <b>상대 ‘장(漢/楚)’을 잡으면 승리</b></div><br/>
        <div style="margin-top:6px;">
          조작: 말 클릭 → 이동 칸 클릭<br/>
          AI 난이도: <b>연승이 올라갈수록</b> 더 똑똑해짐<br/>
          (모바일: 탭으로 플레이)
        </div>
      </div>

      <div class="small">수순 로그</div>
      <div class="log" id="log"></div>
    </div>
  </div>

  <div class="overlay show" id="overlay">
    <div class="card modal">
      <h2>시작 준비!</h2>
      <p>
        당신은 <b>한(아래)</b> 입니다. <br/>
        목표는 단순: <b>상대 ‘장(楚)’ 잡기</b>.<br/><br/>
        조작은 <span class="kbd">클릭/탭</span> 두 번: 말 선택 → 목적지 선택.
      </p>
      <div class="row">
        <button class="primary" id="btnGo">게임 시작</button>
        <button id="btnClose">닫기</button>
      </div>
      <p class="small" style="margin-top:10px;">
        팁: 초반엔 <b>차/포</b> 라인을 열면 유리해요.
      </p>
    </div>
  </div>

<script>
(() => {
  // -------------------------
  // 기본 설정 / 상태
  // -------------------------
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const UI = {
    turnTxt: document.getElementById('turnTxt'),
    diffTxt: document.getElementById('diffTxt'),
    streakTxt: document.getElementById('streakTxt'),
    statusTxt: document.getElementById('statusTxt'),
    log: document.getElementById('log'),
    overlay: document.getElementById('overlay'),
    btnStart: document.getElementById('btnStart'),
    btnNew: document.getElementById('btnNew'),
    btnReset: document.getElementById('btnReset'),
    btnGo: document.getElementById('btnGo'),
    btnClose: document.getElementById('btnClose'),
  };

  const SIDE = { HAN:'H', CHO:'C' }; // 한=플레이어(아래), 초=AI(위)
  const TYPE = { G:'G', A:'A', R:'R', H:'H', E:'E', C:'C', S:'S' }; // 장,사,차,마,상,포,졸

  // 점수(대략)
  const PIECE_VALUE = {
    [TYPE.G]: 100000,
    [TYPE.R]: 900,
    [TYPE.C]: 450,
    [TYPE.H]: 350,
    [TYPE.E]: 300,
    [TYPE.A]: 200,
    [TYPE.S]: 120
  };

  // ✅ 한문 표시
  const HANJA = {
    [TYPE.R]:'車',
    [TYPE.H]:'馬',
    [TYPE.E]:'象',
    [TYPE.A]:'士',
    [TYPE.C]:'炮',
    [TYPE.S]:'卒',
  };
  function pieceText(p){
    if(p.type === TYPE.G){
      return (p.side === SIDE.HAN) ? '漢' : '楚';
    }
    return HANJA[p.type] || '?';
  }

  // SVG 이미지 캐시(단일 파일에서 이미지처럼 쓰기)
  const pieceImgCache = new Map(); // key: "H_G", "C_R"...

  // 10x9 board, y:0(top)~9(bottom), x:0~8
  let board = null;
  let turn = SIDE.HAN;        // 한부터
  let gameOver = false;
  let selected = null;        // {x,y}
  let legalCache = [];        // 선택된 말의 이동 후보
  let moveHistory = [];       // (필요하면 undo용)
  let winStreak = loadStreak();
  let thinking = false;

  // 좌표/그리드
  const GRID = { cols:9, rows:10 };
  const pad = 40;
  const cellW = (cv.width - pad*2) / (GRID.cols-1);
  const cellH = (cv.height - pad*2) / (GRID.rows-1);

  function xyToPx(x,y){ return { px: pad + x*cellW, py: pad + y*cellH }; }
  function pxToXY(px,py){
    const x = Math.round((px - pad)/cellW);
    const y = Math.round((py - pad)/cellH);
    if(x<0||x>=GRID.cols||y<0||y>=GRID.rows) return null;
    const p = xyToPx(x,y);
    const dx = px - p.px, dy = py - p.py;
    if (dx*dx + dy*dy > (Math.min(cellW,cellH)*0.45)**2) return null;
    return {x,y};
  }

  // -------------------------
  // 난이도(연승 기반)
  // -------------------------
  function getDifficulty(streak){
    if(streak <= 0) return { name:'EASY', depth:2, timeMs:220, noise:0.25 };
    if(streak === 1) return { name:'NORMAL', depth:3, timeMs:450, noise:0.14 };
    if(streak === 2) return { name:'HARD', depth:4, timeMs:850, noise:0.08 };
    if(streak === 3) return { name:'PRO', depth:5, timeMs:1300, noise:0.03 };
    return { name:'BOSS', depth:5, timeMs:1700, noise:0.0 };
  }

  // -------------------------
  // 초기 배치 (표준 장기 배치)
  // -------------------------
  function makeEmptyBoard(){
    const b = [];
    for(let y=0;y<10;y++){
      const row = [];
      for(let x=0;x<9;x++) row.push(null);
      b.push(row);
    }
    return b;
  }

  function placeInitial(){
    board = makeEmptyBoard();

    // 초(위)
    put(0,0, SIDE.CHO, TYPE.R); put(8,0, SIDE.CHO, TYPE.R);
    put(1,0, SIDE.CHO, TYPE.H); put(7,0, SIDE.CHO, TYPE.H);
    put(2,0, SIDE.CHO, TYPE.E); put(6,0, SIDE.CHO, TYPE.E);
    put(3,0, SIDE.CHO, TYPE.A); put(5,0, SIDE.CHO, TYPE.A);
    put(4,1, SIDE.CHO, TYPE.G);
    put(1,2, SIDE.CHO, TYPE.C); put(7,2, SIDE.CHO, TYPE.C);
    put(0,3, SIDE.CHO, TYPE.S); put(2,3, SIDE.CHO, TYPE.S); put(4,3, SIDE.CHO, TYPE.S); put(6,3, SIDE.CHO, TYPE.S); put(8,3, SIDE.CHO, TYPE.S);

    // 한(아래)
    put(0,9, SIDE.HAN, TYPE.R); put(8,9, SIDE.HAN, TYPE.R);
    put(1,9, SIDE.HAN, TYPE.H); put(7,9, SIDE.HAN, TYPE.H);
    put(2,9, SIDE.HAN, TYPE.E); put(6,9, SIDE.HAN, TYPE.E);
    put(3,9, SIDE.HAN, TYPE.A); put(5,9, SIDE.HAN, TYPE.A);
    put(4,8, SIDE.HAN, TYPE.G);
    put(1,7, SIDE.HAN, TYPE.C); put(7,7, SIDE.HAN, TYPE.C);
    put(0,6, SIDE.HAN, TYPE.S); put(2,6, SIDE.HAN, TYPE.S); put(4,6, SIDE.HAN, TYPE.S); put(6,6, SIDE.HAN, TYPE.S); put(8,6, SIDE.HAN, TYPE.S);

    turn = SIDE.HAN;
    gameOver = false;
    selected = null;
    legalCache = [];
    moveHistory = [];
    thinking = false;

    UI.statusTxt.textContent = "진행중";
    appendLog("새 판 시작! (漢: 플레이어, 楚: AI)");
    syncUI();
    draw();
  }

  function put(x,y, side, type){
    board[y][x] = { side, type };
  }

  // -------------------------
  // 궁성 / 대각선 라인
  // -------------------------
  function inPalace(side, x,y){
    if(x<3||x>5) return false;
    if(side===SIDE.CHO) return (y>=0 && y<=2);
    return (y>=7 && y<=9);
  }

  function palaceDiagonalConnected(x1,y1,x2,y2){
    const key = (x,y)=> `${x},${y}`;
    const edges = new Set([
      // 위 궁성
      `${key(3,0)}>${key(4,1)}`, `${key(4,1)}>${key(5,2)}`,
      `${key(5,0)}>${key(4,1)}`, `${key(4,1)}>${key(3,2)}`,
      // 아래 궁성
      `${key(3,7)}>${key(4,8)}`, `${key(4,8)}>${key(5,9)}`,
      `${key(5,7)}>${key(4,8)}`, `${key(4,8)}>${key(3,9)}`
    ]);
    const a = `${key(x1,y1)}>${key(x2,y2)}`;
    const b = `${key(x2,y2)}>${key(x1,y1)}`;
    return edges.has(a) || edges.has(b);
  }

  // -------------------------
  // 이동 생성
  // -------------------------
  function inside(x,y){ return x>=0 && x<9 && y>=0 && y<10; }
  function get(x,y){ return board[y][x]; }

  function genMovesForPiece(b, x,y){
    const p = b[y][x];
    if(!p) return [];
    const side = p.side, t = p.type;
    const moves = [];
    const add = (nx,ny) => {
      if(!inside(nx,ny)) return;
      const q = b[ny][nx];
      if(q && q.side===side) return;
      moves.push({fx:x, fy:y, tx:nx, ty:ny});
    };

    if(t===TYPE.R){
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        let nx=x+dx, ny=y+dy;
        while(inside(nx,ny)){
          const q = b[ny][nx];
          if(!q){ moves.push({fx:x,fy:y,tx:nx,ty:ny}); }
          else{
            if(q.side!==side) moves.push({fx:x,fy:y,tx:nx,ty:ny});
            break;
          }
          nx+=dx; ny+=dy;
        }
      }

      const neighbors = (cx,cy)=>{
        const out=[];
        const cand = [[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1],[cx+1,cy+1],[cx-1,cy+1],[cx+1,cy-1],[cx-1,cy-1]];
        for(const [nx,ny] of cand){
          if(!inside(nx,ny)) continue;
          const samePal = (inPalace(SIDE.CHO,cx,cy)&&inPalace(SIDE.CHO,nx,ny)) || (inPalace(SIDE.HAN,cx,cy)&&inPalace(SIDE.HAN,nx,ny));
          if(!samePal) continue;
          const manhattan = Math.abs(nx-cx)+Math.abs(ny-cy);
          if(manhattan===1) out.push([nx,ny]);
          else if(Math.abs(nx-cx)===1 && Math.abs(ny-cy)===1 && palaceDiagonalConnected(cx,cy,nx,ny)) out.push([nx,ny]);
        }
        return out;
      };

      if(inPalace(SIDE.CHO,x,y) || inPalace(SIDE.HAN,x,y)){
        const neigh = neighbors(x,y);
        for(const [nx0,ny0] of neigh){
          let nx=nx0, ny=ny0;
          let px=x, py=y;
          while(true){
            const q = b[ny][nx];
            if(!q){
              moves.push({fx:x,fy:y,tx:nx,ty:ny});
            }else{
              if(q.side!==side) moves.push({fx:x,fy:y,tx:nx,ty:ny});
              break;
            }
            const nxt = neighbors(nx,ny).filter(([ax,ay]) => !(ax===px && ay===py));
            const vx=nx-px, vy=ny-py;
            const keep = nxt.find(([ax,ay]) => (ax-nx)===vx && (ay-ny)===vy);
            if(!keep) break;
            px=nx; py=ny;
            nx=keep[0]; ny=keep[1];
          }
        }
      }
    }

    else if(t===TYPE.C){
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        let nx=x+dx, ny=y+dy;
        while(inside(nx,ny) && !b[ny][nx]){ nx+=dx; ny+=dy; }
        if(!inside(nx,ny)) continue;
        const screen = b[ny][nx];
        if(!screen) continue;
        if(screen.type===TYPE.C) continue; // 포는 포를 못 넘김
        nx+=dx; ny+=dy;
        while(inside(nx,ny)){
          const q = b[ny][nx];
          if(!q){
            moves.push({fx:x,fy:y,tx:nx,ty:ny});
          }else{
            if(q.side!==side && q.type!==TYPE.C){
              moves.push({fx:x,fy:y,tx:nx,ty:ny});
            }
            break;
          }
          nx+=dx; ny+=dy;
        }
      }
    }

    else if(t===TYPE.H){
      const steps = [
        {b:[1,0], d:[1,1]}, {b:[1,0], d:[1,-1]},
        {b:[-1,0], d:[-1,1]}, {b:[-1,0], d:[-1,-1]},
        {b:[0,1], d:[1,1]}, {b:[0,1], d:[-1,1]},
        {b:[0,-1], d:[1,-1]}, {b:[0,-1], d:[-1,-1]},
      ];
      for(const s of steps){
        const bx=x+s.b[0], by=y+s.b[1];
        if(!inside(bx,by)) continue;
        if(b[by][bx]) continue;
        add(x+s.b[0]+s.d[0], y+s.b[1]+s.d[1]);
      }
    }

    else if(t===TYPE.E){
      const patterns = [
        {b1:[1,0], b2:[2,1], to:[3,2]},
        {b1:[1,0], b2:[2,-1], to:[3,-2]},
        {b1:[-1,0], b2:[-2,1], to:[-3,2]},
        {b1:[-1,0], b2:[-2,-1], to:[-3,-2]},
        {b1:[0,1], b2:[1,2], to:[2,3]},
        {b1:[0,1], b2:[-1,2], to:[-2,3]},
        {b1:[0,-1], b2:[1,-2], to:[2,-3]},
        {b1:[0,-1], b2:[-1,-2], to:[-2,-3]},
      ];
      for(const ptn of patterns){
        const b1x=x+ptn.b1[0], b1y=y+ptn.b1[1];
        const b2x=x+ptn.b2[0], b2y=y+ptn.b2[1];
        const tx=x+ptn.to[0], ty=y+ptn.to[1];
        if(!inside(tx,ty) || !inside(b1x,b1y) || !inside(b2x,b2y)) continue;
        if(b[b1y][b1x]) continue;
        if(b[b2y][b2x]) continue;
        add(tx,ty);
      }
    }

    else if(t===TYPE.G || t===TYPE.A){
      const cand = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for(const [dx,dy] of cand){
        const nx=x+dx, ny=y+dy;
        if(!inside(nx,ny)) continue;
        if(!inPalace(side, nx,ny)) continue;
        if(Math.abs(dx)+Math.abs(dy)===2){
          if(!palaceDiagonalConnected(x,y,nx,ny)) continue;
        }
        add(nx,ny);
      }
    }

    else if(t===TYPE.S){
      const dir = (side===SIDE.HAN) ? -1 : 1; // 한은 위로 전진
      add(x, y+dir);
      add(x-1, y);
      add(x+1, y);

      const nx1=x-1, ny1=y+dir;
      const nx2=x+1, ny2=y+dir;
      if(inside(nx1,ny1) && inPalace(side, x,y) && inPalace(side, nx1,ny1) && palaceDiagonalConnected(x,y,nx1,ny1)) add(nx1,ny1);
      if(inside(nx2,ny2) && inPalace(side, x,y) && inPalace(side, nx2,ny2) && palaceDiagonalConnected(x,y,nx2,ny2)) add(nx2,ny2);
    }

    return moves;
  }

  function genAllMoves(b, side){
    const out=[];
    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p=b[y][x];
        if(!p || p.side!==side) continue;
        out.push(...genMovesForPiece(b,x,y));
      }
    }
    return out;
  }

  function cloneBoard(b){
    const nb = [];
    for(let y=0;y<10;y++){
      const row=[];
      for(let x=0;x<9;x++){
        const p=b[y][x];
        row.push(p ? {side:p.side, type:p.type} : null);
      }
      nb.push(row);
    }
    return nb;
  }

  function applyMove(b, mv){
    const nb = cloneBoard(b);
    const p = nb[mv.fy][mv.fx];
    const cap = nb[mv.ty][mv.tx];
    nb[mv.fy][mv.fx]=null;
    nb[mv.ty][mv.tx]=p;
    return { nb, captured: cap };
  }

  // -------------------------
  // AI (알파베타)
  // -------------------------
  function evaluate(b){
    let score=0; // +면 초(AI) 유리
    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p=b[y][x];
        if(!p) continue;
        const v = PIECE_VALUE[p.type] || 0;
        score += (p.side===SIDE.CHO) ? v : -v;
        if(p.type===TYPE.S){
          const adv = (p.side===SIDE.CHO) ? y : (9-y);
          score += (p.side===SIDE.CHO) ? adv*2 : -adv*2;
        }
      }
    }
    return score;
  }

  function pickMoveAI(){
    const diff = getDifficulty(winStreak);
    const start = performance.now();
    const timeLimit = diff.timeMs;

    const side = SIDE.CHO;
    const moves = genAllMoves(board, side);
    if(moves.length===0) return null;

    // 캡처 우선 정렬
    moves.sort((a,b)=> {
      const ca = board[a.ty][a.tx];
      const cb = board[b.ty][b.tx];
      const va = ca ? (PIECE_VALUE[ca.type]||0) : 0;
      const vb = cb ? (PIECE_VALUE[cb.type]||0) : 0;
      return vb - va;
    });

    let best = moves[0];
    let bestScore = -Infinity;

    function winnerByCapturedGeneral(b){
      // 보드 스캔: 장이 없으면 끝
      let hasHanG=false, hasChoG=false;
      for(let y=0;y<10;y++){
        for(let x=0;x<9;x++){
          const p=b[y][x];
          if(!p) continue;
          if(p.type===TYPE.G){
            if(p.side===SIDE.HAN) hasHanG=true;
            else hasChoG=true;
          }
        }
      }
      if(!hasChoG) return SIDE.HAN;
      if(!hasHanG) return SIDE.CHO;
      return null;
    }

    function alphabeta(b, depth, alpha, beta, maximizing){
      if(performance.now() - start > timeLimit) return evaluate(b);

      const winner = winnerByCapturedGeneral(b);
      if(winner===SIDE.CHO) return  999999;
      if(winner===SIDE.HAN) return -999999;

      if(depth===0) return evaluate(b);

      const s = maximizing ? SIDE.CHO : SIDE.HAN;
      const ms = genAllMoves(b, s);
      if(ms.length===0) return evaluate(b);

      ms.sort((m1,m2)=>{
        const c1 = b[m1.ty][m1.tx];
        const c2 = b[m2.ty][m2.tx];
        const v1 = c1 ? (PIECE_VALUE[c1.type]||0) : 0;
        const v2 = c2 ? (PIECE_VALUE[c2.type]||0) : 0;
        return v2 - v1;
      });

      if(maximizing){
        let v=-Infinity;
        for(const mv of ms){
          const {nb} = applyMove(b,mv);
          v = Math.max(v, alphabeta(nb, depth-1, alpha, beta, false));
          alpha = Math.max(alpha, v);
          if(beta <= alpha) break;
        }
        return v;
      }else{
        let v=Infinity;
        for(const mv of ms){
          const {nb} = applyMove(b,mv);
          v = Math.min(v, alphabeta(nb, depth-1, alpha, beta, true));
          beta = Math.min(beta, v);
          if(beta <= alpha) break;
        }
        return v;
      }
    }

    for(const mv of moves){
      if(performance.now() - start > timeLimit) break;
      const {nb} = applyMove(board, mv);
      let sc = alphabeta(nb, diff.depth-1, -Infinity, Infinity, false);
      if(diff.noise>0){
        sc += (Math.random()*2-1) * diff.noise * 200;
      }
      if(sc > bestScore){
        bestScore = sc;
        best = mv;
      }
    }
    return best;
  }

  // -------------------------
  // 입력 / 게임 진행
  // -------------------------
  function isPlayersTurn(){ return turn===SIDE.HAN && !gameOver && !thinking; }

  function handleTap(ev){
    if(!isPlayersTurn()) return;

    const rect = cv.getBoundingClientRect();
    const scaleX = cv.width / rect.width;
    const scaleY = cv.height / rect.height;
    const px = (ev.clientX - rect.left) * scaleX;
    const py = (ev.clientY - rect.top) * scaleY;
    const cell = pxToXY(px,py);
    if(!cell) return;

    const {x,y} = cell;
    const p = get(x,y);

    if(selected){
      const mv = legalCache.find(m => m.tx===x && m.ty===y);
      if(mv){
        doMove(mv);
        return;
      }
      if(p && p.side===SIDE.HAN){
        selectAt(x,y);
      }else{
        selected=null; legalCache=[];
        draw();
      }
    }else{
      if(p && p.side===SIDE.HAN){
        selectAt(x,y);
      }
    }
  }

  function selectAt(x,y){
    selected = {x,y};
    legalCache = genMovesForPiece(board,x,y);
    draw();
  }

  function doMove(mv){
    if(gameOver) return;

    const p = board[mv.fy][mv.fx];
    const cap = board[mv.ty][mv.tx];

    moveHistory.push({
      board: cloneBoard(board),
      turn,
      streak: winStreak
    });

    board[mv.fy][mv.fx] = null;
    board[mv.ty][mv.tx] = p;

    // ✅ 핵심: "장을 잡으면 즉시 종료"
    if (cap && cap.type === TYPE.G) {
      appendLog(`${p.side===SIDE.HAN ? '漢' : '楚'}: ${pieceText(p)}가 상대 장을 잡았습니다!`);
      endGame(p.side);
      draw();
      return;
    }

    selected=null; legalCache=[];
    appendLog(`${p.side===SIDE.HAN ? '漢' : '楚'}: ${pieceText(p)} (${mv.fx},${mv.fy})→(${mv.tx},${mv.ty})` + (cap ? `  [${pieceText(cap)} 잡음]` : ""));

    // 턴 교대
    turn = (turn===SIDE.HAN) ? SIDE.CHO : SIDE.HAN;
    syncUI();
    draw();

    // AI 턴
    if(turn===SIDE.CHO){
      thinking = true;
      syncUI();

      setTimeout(() => {
        // ✅ 게임이 끝났다면 AI 실행 취소
        if (gameOver) { thinking=false; syncUI(); return; }

        const aiMv = pickMoveAI();
        thinking = false;

        if (gameOver) { syncUI(); return; }
        if(!aiMv){
          endGame(SIDE.HAN);
          draw();
          return;
        }
        doMove(aiMv);
      }, 50);
    }
  }

  function endGame(winner){
    // ✅ 멈춤 방지: thinking 끄기
    thinking = false;

    gameOver = true;
    const msg = (winner===SIDE.HAN) ? "승리! (상대 ‘楚’를 잡았습니다)" : "패배… (내 ‘漢’이 잡혔습니다)";
    appendLog("================================");
    appendLog(msg);

    if(winner===SIDE.HAN){
      winStreak++;
      saveStreak(winStreak);
      UI.statusTxt.textContent = "승리";
    }else{
      winStreak = 0;
      saveStreak(winStreak);
      UI.statusTxt.textContent = "패배";
    }
    syncUI();
  }

  // -------------------------
  // SVG 말 이미지 생성 (단일 파일)
  // -------------------------
  function getPieceImage(p){
    const key = `${p.side}_${p.type}`;
    if(pieceImgCache.has(key)) return pieceImgCache.get(key);

    const txt = pieceText(p);
    const isHan = (p.side === SIDE.HAN);

    const ring = isHan ? '#56f2a6' : '#ff5d5d';
    const glow = isHan ? 'rgba(86,242,166,.35)' : 'rgba(255,93,93,.35)';
    const fill = 'rgba(15,22,34,.92)';

    const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="128" height="128">
      <defs>
        <filter id="shadow" x="-30%" y="-30%" width="160%" height="160%">
          <feDropShadow dx="0" dy="6" stdDeviation="4" flood-color="${glow}"/>
        </filter>
        <radialGradient id="g" cx="35%" cy="25%" r="70%">
          <stop offset="0%" stop-color="rgba(255,255,255,.12)"/>
          <stop offset="55%" stop-color="rgba(255,255,255,.03)"/>
          <stop offset="100%" stop-color="rgba(0,0,0,.25)"/>
        </radialGradient>
      </defs>

      <g filter="url(#shadow)">
        <circle cx="64" cy="64" r="54" fill="${fill}" stroke="${ring}" stroke-width="6"/>
        <circle cx="64" cy="64" r="50" fill="url(#g)" opacity="0.9"/>
        <circle cx="64" cy="64" r="54" fill="none" stroke="rgba(215,224,234,.35)" stroke-width="2"/>
        <text x="64" y="78"
          text-anchor="middle"
          font-size="58"
          font-weight="900"
          fill="${ring}"
          font-family="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace">
          ${txt}
        </text>
      </g>
    </svg>`.trim();

    const img = new Image();
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    pieceImgCache.set(key, img);
    return img;
  }

  // -------------------------
  // 렌더링
  // -------------------------
  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);

    // 배경 그리드
    ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(42,58,82,.9)";

    const tl = xyToPx(0,0);
    const br = xyToPx(8,9);
    ctx.beginPath();
    ctx.rect(tl.px, tl.py, br.px - tl.px, br.py - tl.py);
    ctx.stroke();

    ctx.lineWidth = 2;
    for(let x=0;x<9;x++){
      const p1 = xyToPx(x,0), p2 = xyToPx(x,9);
      ctx.beginPath();
      ctx.moveTo(p1.px,p1.py);
      ctx.lineTo(p2.px,p2.py);
      ctx.stroke();
    }
    for(let y=0;y<10;y++){
      const p1 = xyToPx(0,y), p2 = xyToPx(8,y);
      ctx.beginPath();
      ctx.moveTo(p1.px,p1.py);
      ctx.lineTo(p2.px,p2.py);
      ctx.stroke();
    }

    drawPalaceLines();

    // 이동 후보 하이라이트
    if(selected){
      for(const m of legalCache){
        const c = xyToPx(m.tx,m.ty);
        ctx.beginPath();
        ctx.fillStyle = "rgba(244,211,94,.22)";
        ctx.arc(c.px, c.py, Math.min(cellW,cellH)*0.22, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // 말
    for(let y=0;y<10;y++){
      for(let x=0;x<9;x++){
        const p = board[y][x];
        if(!p) continue;
        drawPiece(x,y,p);
      }
    }

    // 선택 테두리
    if(selected){
      const c = xyToPx(selected.x, selected.y);
      ctx.lineWidth = 6;
      ctx.strokeStyle = "rgba(244,211,94,.95)";
      ctx.beginPath();
      ctx.arc(c.px,c.py, Math.min(cellW,cellH)*0.40, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  function drawPalaceLines(){
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(145,160,177,.6)";

    const lines = [
      [[3,0],[5,2]], [[5,0],[3,2]],
      [[3,7],[5,9]], [[5,7],[3,9]],
    ];
    for(const [[x1,y1],[x2,y2]] of lines){
      const a=xyToPx(x1,y1), b=xyToPx(x2,y2);
      ctx.beginPath();
      ctx.moveTo(a.px,a.py);
      ctx.lineTo(b.px,b.py);
      ctx.stroke();
    }
  }

  function drawPiece(x,y,p){
    const c = xyToPx(x,y);
    const r = Math.min(cellW,cellH)*0.38;

    const img = getPieceImage(p);
    const size = r*2.25;

    if(!img.complete){
      // fallback
      ctx.beginPath();
      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.arc(c.px,c.py,r,0,Math.PI*2);
      ctx.fill();

      ctx.fillStyle = (p.side===SIDE.HAN) ? "rgba(86,242,166,.95)" : "rgba(255,93,93,.95)";
      ctx.font = `bold ${Math.floor(r*1.1)}px ui-monospace, monospace`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(pieceText(p), c.px, c.py+1);
      return;
    }

    ctx.drawImage(img, c.px - size/2, c.py - size/2, size, size);
  }

  // -------------------------
  // UI / 로그 / 저장
  // -------------------------
  function appendLog(s){
    UI.log.textContent += (UI.log.textContent ? "\n" : "") + s;
    UI.log.scrollTop = UI.log.scrollHeight;
  }

  function syncUI(){
    const diff = getDifficulty(winStreak);
    UI.turnTxt.textContent =
      gameOver ? "-" :
      thinking ? "楚(AI) 생각중…" :
      (turn===SIDE.HAN ? "漢(플레이어)" : "楚(AI)");

    UI.diffTxt.textContent = diff.name;
    UI.streakTxt.textContent = String(winStreak);

    if(!gameOver && !thinking) UI.statusTxt.textContent = "진행중";
  }

  function saveStreak(v){
    try{ localStorage.setItem("janggi_streak", String(v)); }catch(e){}
  }
  function loadStreak(){
    try{
      const v = localStorage.getItem("janggi_streak");
      const n = v ? parseInt(v,10) : 0;
      return Number.isFinite(n) ? n : 0;
    }catch(e){ return 0; }
  }

  // -------------------------
  // 버튼 / 오버레이
  // -------------------------
  UI.btnStart.addEventListener('click', () => {
    UI.overlay.classList.add('show');
  });
  UI.btnGo.addEventListener('click', () => {
    UI.overlay.classList.remove('show');
    if(!board) placeInitial();
  });
  UI.btnClose.addEventListener('click', () => UI.overlay.classList.remove('show'));

  UI.btnNew.addEventListener('click', () => placeInitial());
  UI.btnReset.addEventListener('click', () => {
    winStreak = 0;
    saveStreak(winStreak);
    appendLog("연승 리셋!");
    syncUI();
    draw();
  });

  // ✅ 입력(스크롤 방지): passive:false + preventDefault
  cv.addEventListener('pointerdown', (ev) => {
    ev.preventDefault();
    handleTap(ev);
  }, { passive: false });

  // 첫 화면
  syncUI();
  placeInitial();
})();
</script>
</body>
</html>
